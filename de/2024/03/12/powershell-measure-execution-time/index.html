<!doctype html><html lang=de dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Die Ausf√ºhrungsdauer von PowerShell Code messen | diecknet</title>
<meta name=keywords content="powershell,measure,optimization,timespan"><meta name=description content="Wenn ihr euren PowerShell Code auf Geschwindigkeit optimieren wollt, dann macht es Sinn Zeiten zu messen. Es gibt mehrere M√∂glichkeiten um zu messen, wie lange die Ausf√ºhrung von einem St√ºck PowerShell Code dauert.
üé¨ Ich habe √ºbrigens auch ein Video zu dem Thema erstellt.
M√∂glichkeit 1: Measure-Command Eine einfache M√∂glichkeit ist das Cmdlet Measure-Command. Es nimmt einen ScriptBlock entgegen, der dann auch ausgef√ºhrt wird. Und wir erhalten im Anschluss ein Messergebnis in Form eines TimeSpan Objekts."><meta name=author content="Andreas Dieckmann"><link rel=canonical href=https://diecknet.de/de/2024/03/12/powershell-measure-execution-time/><link crossorigin=anonymous href=/assets/css/stylesheet.75a517428f403193483801122d6350f6956c3bb6bf5c6504311f8c24e6bab3e7.css integrity="sha256-daUXQo9AMZNIOAESLWNQ9pVsO7a/XGUEMR+MJOa6s+c=" rel="preload stylesheet" as=style><link rel=icon href=https://diecknet.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diecknet.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diecknet.de/favicon-32x32.png><link rel=apple-touch-icon href=https://diecknet.de/apple-touch-icon.png><link rel=mask-icon href=https://diecknet.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=de href=https://diecknet.de/de/2024/03/12/powershell-measure-execution-time/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Die Ausf√ºhrungsdauer von PowerShell Code messen"><meta property="og:description" content="Wenn ihr euren PowerShell Code auf Geschwindigkeit optimieren wollt, dann macht es Sinn Zeiten zu messen. Es gibt mehrere M√∂glichkeiten um zu messen, wie lange die Ausf√ºhrung von einem St√ºck PowerShell Code dauert.
üé¨ Ich habe √ºbrigens auch ein Video zu dem Thema erstellt.
M√∂glichkeit 1: Measure-Command Eine einfache M√∂glichkeit ist das Cmdlet Measure-Command. Es nimmt einen ScriptBlock entgegen, der dann auch ausgef√ºhrt wird. Und wir erhalten im Anschluss ein Messergebnis in Form eines TimeSpan Objekts."><meta property="og:type" content="article"><meta property="og:url" content="https://diecknet.de/de/2024/03/12/powershell-measure-execution-time/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-12T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Die Ausf√ºhrungsdauer von PowerShell Code messen"><meta name=twitter:description content="Wenn ihr euren PowerShell Code auf Geschwindigkeit optimieren wollt, dann macht es Sinn Zeiten zu messen. Es gibt mehrere M√∂glichkeiten um zu messen, wie lange die Ausf√ºhrung von einem St√ºck PowerShell Code dauert.
üé¨ Ich habe √ºbrigens auch ein Video zu dem Thema erstellt.
M√∂glichkeit 1: Measure-Command Eine einfache M√∂glichkeit ist das Cmdlet Measure-Command. Es nimmt einen ScriptBlock entgegen, der dann auch ausgef√ºhrt wird. Und wir erhalten im Anschluss ein Messergebnis in Form eines TimeSpan Objekts."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://diecknet.de/de/posts/"},{"@type":"ListItem","position":2,"name":"Die Ausf√ºhrungsdauer von PowerShell Code messen","item":"https://diecknet.de/de/2024/03/12/powershell-measure-execution-time/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Die Ausf√ºhrungsdauer von PowerShell Code messen","name":"Die Ausf√ºhrungsdauer von PowerShell Code messen","description":"Wenn ihr euren PowerShell Code auf Geschwindigkeit optimieren wollt, dann macht es Sinn Zeiten zu messen. Es gibt mehrere M√∂glichkeiten um zu messen, wie lange die Ausf√ºhrung von einem St√ºck PowerShell Code dauert.\nüé¨ Ich habe √ºbrigens auch ein Video zu dem Thema erstellt.\nM√∂glichkeit 1: Measure-Command Eine einfache M√∂glichkeit ist das Cmdlet Measure-Command. Es nimmt einen ScriptBlock entgegen, der dann auch ausgef√ºhrt wird. Und wir erhalten im Anschluss ein Messergebnis in Form eines TimeSpan Objekts.","keywords":["powershell","measure","optimization","timespan"],"articleBody":"Wenn ihr euren PowerShell Code auf Geschwindigkeit optimieren wollt, dann macht es Sinn Zeiten zu messen. Es gibt mehrere M√∂glichkeiten um zu messen, wie lange die Ausf√ºhrung von einem St√ºck PowerShell Code dauert.\nüé¨ Ich habe √ºbrigens auch ein Video zu dem Thema erstellt.\nM√∂glichkeit 1: Measure-Command Eine einfache M√∂glichkeit ist das Cmdlet Measure-Command. Es nimmt einen ScriptBlock entgegen, der dann auch ausgef√ºhrt wird. Und wir erhalten im Anschluss ein Messergebnis in Form eines TimeSpan Objekts. Ein einfaches Beispiel daf√ºr:\n1 Measure-Command { Get-Disk } Aber wir k√∂nnen auch mehr messen, als nur einen einzelnen Befehl. Hier ein Beispiel bei dem ein l√§ngerer Code ausgef√ºhrt und gemessen wird.\n1 2 3 4 5 Measure-Command { ($i = 0; $i -lt 100; $i++) { \"Hallo $i\" } } Das zur√ºckgegebene TimeSpan Objekt hat mehreren Eigenschaften. Ich w√ºrde hier in der Regel mit den Eigenschaften arbeiten, die mit ‚ÄúTotal‚Äù anfangen - die zeigen n√§mlich die komplette Dauer. Aber die Zeitangaben ohne ‚ÄúTotal‚Äù als Pr√§fix k√∂nnen auch einen guten √úberblick geben.\nWas euch aber vielleicht aufgefallen ist: Die eigentliche Ausgabe von den Befehlen die wir messen - die ist gar nicht sichtbar. Zumindest die Ausgaben, die in die normalen Output Streams reingeschrieben werden. Eine Ausnahme w√§re Write-Host. Denn Write-Host schreibt zwar auch in den Information Stream, aber sorgt auch daf√ºr, dass die Ausgabe direkt an den Konsolenhost gesendet wird. Wenn ich also Write-Host innerhalb des Measure-Command Blocks verwende um Text auszugeben, dann funktioniert es.\n1 2 3 4 5 Measure-Command { for($i = 0; $i -lt 5; $i++) { Write-Host \"Hallo $i\" } } Aber das ist auch nicht f√ºr alle Szenarien geeignet. Manchmal m√∂chte man ja vielleicht ein komplettes Objekt ausgeben beziehungsweise die R√ºckgabe von einem Cmdlet direkt sehen, trotz Messung. In dem Fall ist die andere Methode besser geeignet.\nM√∂glichkeit 2: Stopwatch .NET Objekt Eine andere M√∂glichkeit um Zeiten zu messen ist mit dem .NET Objekt Stopwatch - also zu deutsch Stoppuhr. Wenn wir jetzt die Ausf√ºhrungsdauer von einem St√ºck PowerShell Code messen wollen, dann starten wir einfach davor die Stoppuhr und beenden sie nach dem Code. Anschlie√üend k√∂nnen wir unser Ergebnis anzeigen. Ich erstelle das Objekt mit einem Aufruf der Methode StartNew() aus der Klasse System.Diagnostics.Stopwatch. Damit wird in einem Schritt ein StopWatch Objekt erstellt und die Stoppuhr gestartet. Theoretisch k√∂nnte man auch erst das Objekt erstellen und dann den Messvorgang starten, aber ich finde es so besser, weil es weniger Code erfordert. Anschlie√üend nehmen wir unseren ganzen PowerShell Code der gemessen werden soll. Es ist hier nicht notwendig den Code noch mit geschweiften Klammern {} zu umschlie√üen. Nach unserem eigentlichen Code rufen wir die Stop() Methode des Stopwatch Objekts auf. Dadurch ist die Messung aber nur beendet, das Ergebnis wird noch nicht angezeigt. Um das Ergebnis zu sehen, schauen wir uns die Elapsed Eigenschaft des StopWatch Objekts an. Das liefert uns wie auch schon die Measure-Command Funktion ein TimeSpan Objekt zur√ºck. Auch hier finde ich die ‚ÄúTotal‚Äù Eigenschaften praktischer, die die Gesamtdauer des Vorgangs repr√§sentieren.\n1 2 3 4 5 6 $StopWatch = [System.Diagnostics.Stopwatch]::StartNew() \"Wie lange dauert dieser Code wohl..?\" $StopWatch.Stop() $StopWatch.Elapsed Mehrfach Messen ist sinnvoll Egal welche der beiden M√∂glichkeiten ihr verwendet: Es macht Sinn nicht nur einmal zu messen, sondern mehrfach. Und je nachdem was ihr messt, k√∂nnen die Ergebnisse auch schon dadurch verf√§lscht sein, dass etwas zwischen gecached ist oder noch nicht gecached ist. Also zum Beispiel, wenn ihr ein Cmdlet verwendet, welches aus irgendeinem heruntergelandenen Modul kommt. Wenn ihr noch kein anderes Cmdlet aus dem Modul ausgef√ºhrt habt und das Modul nicht explizit geladen habt, dann versucht PowerShell erstmal das Cmdlet zu finden und dann wenn es das Modul gefunden hat, dann wird das Modul geladen. Und dann erst wird das Cmdlet ausgef√ºhrt. Dadurch kann dann die erste Ausf√ºhrung von einem Befehl l√§nger dauern, als alle weiteren sp√§teren Ausf√ºhrungen. In den meisten F√§llen fahrt ihr dann besser, wenn ihr das entsprechende Modul schon vorab mit Import-Module ladet und dann erst eure Messungen durchf√ºhrt. Also um sicherzugehen, dass die Testergebnisse nicht verzerrt werden. Hier mal ein kleines Beispiel wie man ein St√ºck Code mehrfach (1000 Mal!) testen k√∂nnte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u003c# Ich verwende hier eine Generic List zum Speichern der Testergebnisse, die eignet sich besser dazu Daten aus einer Schleife hinzuzuf√ºgen. #\u003e $AllTests = [System.Collections.Generic.List[PSObject]]::new() for($i = 0; $i -lt 1000; $i++) { $StopWatch = [System.Diagnostics.Stopwatch]::StartNew() \"Wie lange dauert dieser Code wohl..?\" $StopWatch.Stop() $AllTests.Add($StopWatch.Elapsed) } # Einfache √úbersicht mit Minimum, Maximum und Durchschnitt $AllTests.TotalMilliseconds | Measure-Object -Average -Maximum -Minimum Man kann die Daten bestimmt auch noch besser und sinnvoller aufbereiten, aber f√ºr einfache Szenarien hat mir das so immer ausgereicht.\nWeiterf√ºhrende Links PowerShell Cmdlet Measure-Command: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-5.1 .NET Klasse StopWatch: https://learn.microsoft.com/de-de/dotnet/api/system.diagnostics.stopwatch.startnew?view=netframework-4.8.1 ","wordCount":"789","inLanguage":"de","datePublished":"2024-03-12T00:00:00Z","dateModified":"2024-03-12T00:00:00Z","author":{"@type":"Person","name":"Andreas Dieckmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diecknet.de/de/2024/03/12/powershell-measure-execution-time/"},"publisher":{"@type":"Organization","name":"diecknet","logo":{"@type":"ImageObject","url":"https://diecknet.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diecknet.de/de/ accesskey=h title="diecknet (Alt + H)">diecknet</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://diecknet.de/de/ title=Deutsch aria-label=Deutsch><b>Deutsch</b></a></li><li><a href=https://diecknet.de/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://diecknet.de/de/ title=Home><span>Home</span></a></li><li><a href=https://diecknet.de/de/services/ title=Services><span>Services</span></a></li><li><a href=https://diecknet.de/de/about/ title=About><span>About</span></a></li><li><a href=https://diecknet.de/de/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://diecknet.de/de/archive/ title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://diecknet.de/de/>Home</a>&nbsp;¬ª&nbsp;<a href=https://diecknet.de/de/posts/>Posts</a></div><h1 class=post-title>Die Ausf√ºhrungsdauer von PowerShell Code messen</h1><div class=post-meta><span title='2024-03-12 00:00:00 +0000 UTC'>2024-03-12</span>&nbsp;¬∑&nbsp;4 Minuten&nbsp;¬∑&nbsp;Andreas Dieckmann&nbsp;|&nbsp;<a href=https://github.com/diecknet/diecknet-blog/tree/main/content/de/posts/2024/2024-03-12-PowerShell-Measure-Execution-Time.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Inhaltsverzeichnis</span></summary><div class=inner><ul><li><a href=#m%c3%b6glichkeit-1-measure-command aria-label="M√∂glichkeit 1: Measure-Command">M√∂glichkeit 1: Measure-Command</a></li><li><a href=#m%c3%b6glichkeit-2-stopwatch-net-objekt aria-label="M√∂glichkeit 2: Stopwatch .NET Objekt">M√∂glichkeit 2: Stopwatch .NET Objekt</a></li><li><a href=#mehrfach-messen-ist-sinnvoll aria-label="Mehrfach Messen ist sinnvoll">Mehrfach Messen ist sinnvoll</a></li><li><a href=#weiterf%c3%bchrende-links aria-label="Weiterf√ºhrende Links">Weiterf√ºhrende Links</a></li></ul></div></details></div><div class=post-content><p>Wenn ihr euren PowerShell Code auf Geschwindigkeit optimieren wollt, dann macht es Sinn Zeiten zu messen. Es gibt mehrere M√∂glichkeiten um zu messen, wie lange die Ausf√ºhrung von einem St√ºck PowerShell Code dauert.<br><strong>üé¨ Ich habe √ºbrigens auch ein <a href=https://youtu.be/-tpR-KQpPq4 target=_blank>Video zu dem Thema erstellt.</a></strong></p><h2 id=m√∂glichkeit-1-measure-command>M√∂glichkeit 1: Measure-Command<a hidden class=anchor aria-hidden=true href=#m√∂glichkeit-1-measure-command>#</a></h2><p>Eine einfache M√∂glichkeit ist das Cmdlet <code>Measure-Command</code>. Es nimmt einen ScriptBlock entgegen, der dann auch ausgef√ºhrt wird. Und wir erhalten im Anschluss ein Messergebnis in Form eines <code>TimeSpan</code> Objekts. Ein einfaches Beispiel daf√ºr:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Measure-Command</span> { <span style=color:#d0a8ff>Get-Disk</span> }
</span></span></code></pre></td></tr></table></div></div><p><a href=/images/2024/2024-03-12_PowerShell_Execution_Time_Measure-Command_1.jpg><img loading=lazy src=/images/2024/2024-03-12_PowerShell_Execution_Time_Measure-Command_1.jpg alt="Messung per Measure-Command" title="Messung per Measure-Command"></a></p><p>Aber wir k√∂nnen auch mehr messen, als nur einen einzelnen Befehl. Hier ein Beispiel bei dem ein l√§ngerer Code ausgef√ºhrt und gemessen wird.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Measure-Command</span> {
</span></span><span style=display:flex><span>    (<span style=color:#41a1c0>$i</span> = <span style=color:#d0bf69>0</span>; <span style=color:#41a1c0>$i</span> -lt <span style=color:#d0bf69>100</span>; <span style=color:#41a1c0>$i</span>++) {
</span></span><span style=display:flex><span>        <span style=color:#fc6a5d>&#34;Hallo </span><span style=color:#41a1c0>$i</span><span style=color:#fc6a5d>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><a href=/images/2024/2024-03-12_PowerShell_Execution_Time_Measure-Command_2.jpg><img loading=lazy src=/images/2024/2024-03-12_PowerShell_Execution_Time_Measure-Command_2.jpg alt="L√§ngere Messung per Measure-Command" title="L√§ngere Messung per Measure-Command"></a></p><p>Das zur√ºckgegebene TimeSpan Objekt hat mehreren Eigenschaften. Ich w√ºrde hier in der Regel mit den Eigenschaften arbeiten, die mit &ldquo;Total&rdquo; anfangen - die zeigen n√§mlich die komplette Dauer. Aber die Zeitangaben ohne &ldquo;Total&rdquo; als Pr√§fix k√∂nnen auch einen guten √úberblick geben.</p><p>Was euch aber vielleicht aufgefallen ist: Die eigentliche Ausgabe von den Befehlen die wir messen - die ist gar nicht sichtbar. Zumindest die Ausgaben, die in die normalen Output Streams reingeschrieben werden. Eine Ausnahme w√§re <code>Write-Host</code>. Denn <code>Write-Host</code> schreibt zwar auch in den Information Stream, aber sorgt auch daf√ºr, dass die Ausgabe direkt an den Konsolenhost gesendet wird. Wenn ich also <code>Write-Host</code> innerhalb des <code>Measure-Command</code> Blocks verwende um Text auszugeben, dann funktioniert es.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Measure-Command</span> {
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>for</span>(<span style=color:#41a1c0>$i</span> = <span style=color:#d0bf69>0</span>; <span style=color:#41a1c0>$i</span> -lt <span style=color:#d0bf69>5</span>; <span style=color:#41a1c0>$i</span>++) {
</span></span><span style=display:flex><span>        <span style=color:#d0a8ff>Write-Host</span> <span style=color:#fc6a5d>&#34;Hallo </span><span style=color:#41a1c0>$i</span><span style=color:#fc6a5d>&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><a href=/images/2024/2024-03-12_PowerShell_Execution_Time_Measure-Command_3.jpg><img loading=lazy src=/images/2024/2024-03-12_PowerShell_Execution_Time_Measure-Command_3.jpg alt="Text-Ausgabe per Write-Host bei Verwendung von Measure-Command" title="Text-Ausgabe per Write-Host bei Verwendung von Measure-Command"></a></p><p>Aber das ist auch nicht f√ºr alle Szenarien geeignet. Manchmal m√∂chte man ja vielleicht ein komplettes Objekt ausgeben beziehungsweise die R√ºckgabe von einem Cmdlet direkt sehen, trotz Messung. In dem Fall ist die andere Methode besser geeignet.</p><h2 id=m√∂glichkeit-2-stopwatch-net-objekt>M√∂glichkeit 2: Stopwatch .NET Objekt<a hidden class=anchor aria-hidden=true href=#m√∂glichkeit-2-stopwatch-net-objekt>#</a></h2><p>Eine andere M√∂glichkeit um Zeiten zu messen ist mit dem .NET Objekt <code>Stopwatch</code> - also zu deutsch Stoppuhr. Wenn wir jetzt die Ausf√ºhrungsdauer von einem St√ºck PowerShell Code messen wollen, dann starten wir einfach davor die Stoppuhr und beenden sie nach dem Code. Anschlie√üend k√∂nnen wir unser Ergebnis anzeigen.
Ich erstelle das Objekt mit einem Aufruf der Methode <code>StartNew()</code> aus der Klasse <code>System.Diagnostics.Stopwatch</code>. Damit wird in einem Schritt ein StopWatch Objekt erstellt und die Stoppuhr gestartet. Theoretisch k√∂nnte man auch erst das Objekt erstellen und dann den Messvorgang starten, aber ich finde es so besser, weil es weniger Code erfordert.
Anschlie√üend nehmen wir unseren ganzen PowerShell Code der gemessen werden soll. Es ist hier <strong>nicht notwendig</strong> den Code noch mit geschweiften Klammern <code>{}</code> zu umschlie√üen. Nach unserem eigentlichen Code rufen wir die <code>Stop()</code> Methode des Stopwatch Objekts auf. Dadurch ist die Messung aber nur beendet, das Ergebnis wird noch nicht angezeigt. Um das Ergebnis zu sehen, schauen wir uns die <code>Elapsed</code> Eigenschaft des StopWatch Objekts an. Das liefert uns wie auch schon die <code>Measure-Command</code> Funktion ein <code>TimeSpan</code> Objekt zur√ºck. Auch hier finde ich die &ldquo;Total&rdquo; Eigenschaften praktischer, die die Gesamtdauer des Vorgangs repr√§sentieren.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#41a1c0>$StopWatch</span> = [System.Diagnostics.Stopwatch]::StartNew()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc6a5d>&#34;Wie lange dauert dieser Code wohl..?&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$StopWatch</span>.Stop()
</span></span><span style=display:flex><span><span style=color:#41a1c0>$StopWatch</span>.Elapsed
</span></span></code></pre></td></tr></table></div></div><p><a href=/images/2024/2024-03-12_PowerShell_Execution_Time_NET_Stopwatch_1.jpg><img loading=lazy src=/images/2024/2024-03-12_PowerShell_Execution_Time_NET_Stopwatch_1.jpg alt="Messung per .NET Stopwatch Objekt in PowerShell" title="Messung per .NET Stopwatch Objekt in PowerShell"></a></p><h2 id=mehrfach-messen-ist-sinnvoll>Mehrfach Messen ist sinnvoll<a hidden class=anchor aria-hidden=true href=#mehrfach-messen-ist-sinnvoll>#</a></h2><p>Egal welche der beiden M√∂glichkeiten ihr verwendet: Es macht Sinn nicht nur einmal zu messen, sondern mehrfach. Und je nachdem was ihr messt, k√∂nnen die Ergebnisse auch schon dadurch verf√§lscht sein, dass etwas zwischen gecached ist oder noch nicht gecached ist. Also zum Beispiel, wenn ihr ein Cmdlet verwendet, welches aus irgendeinem heruntergelandenen Modul kommt. Wenn ihr noch kein anderes Cmdlet aus dem Modul ausgef√ºhrt habt und das Modul nicht explizit geladen habt, dann versucht PowerShell erstmal das Cmdlet zu finden und dann wenn es das Modul gefunden hat, dann wird das Modul geladen. Und dann erst wird das Cmdlet ausgef√ºhrt. Dadurch kann dann die erste Ausf√ºhrung von einem Befehl l√§nger dauern, als alle weiteren sp√§teren Ausf√ºhrungen.
In den meisten F√§llen fahrt ihr dann besser, wenn ihr das entsprechende Modul schon vorab mit <code>Import-Module</code> ladet und dann erst eure Messungen durchf√ºhrt. Also um sicherzugehen, dass die Testergebnisse nicht verzerrt werden.
Hier mal ein kleines Beispiel wie man ein St√ºck Code mehrfach (1000 Mal!) testen k√∂nnte:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986>&lt;# 
</span></span></span><span style=display:flex><span><span style=color:#6c7986>    Ich verwende hier eine Generic List zum Speichern der Testergebnisse,
</span></span></span><span style=display:flex><span><span style=color:#6c7986>    die eignet sich besser dazu Daten aus einer Schleife hinzuzuf√ºgen.
</span></span></span><span style=display:flex><span><span style=color:#6c7986>#&gt;</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$AllTests</span> = [System.Collections.Generic.List[PSObject]]::new()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc5fa3>for</span>(<span style=color:#41a1c0>$i</span> = <span style=color:#d0bf69>0</span>; <span style=color:#41a1c0>$i</span> -lt <span style=color:#d0bf69>1000</span>; <span style=color:#41a1c0>$i</span>++) {
</span></span><span style=display:flex><span>    <span style=color:#41a1c0>$StopWatch</span> = [System.Diagnostics.Stopwatch]::StartNew()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc6a5d>&#34;Wie lange dauert dieser Code wohl..?&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#41a1c0>$StopWatch</span>.Stop()
</span></span><span style=display:flex><span>    <span style=color:#41a1c0>$AllTests</span>.Add(<span style=color:#41a1c0>$StopWatch</span>.Elapsed)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Einfache √úbersicht mit Minimum, Maximum und Durchschnitt</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$AllTests</span>.TotalMilliseconds | <span style=color:#d0a8ff>Measure-Object</span> -Average -Maximum -Minimum
</span></span></code></pre></td></tr></table></div></div><p><a href=/images/2024/2024-03-12_PowerShell_Execution_Time_NET_Stopwatch_2.jpg><img loading=lazy src=/images/2024/2024-03-12_PowerShell_Execution_Time_NET_Stopwatch_2.jpg alt="Mehrfache Messung per .NET Stopwatch Objekt in PowerShell" title="Mehrfache Messung per .NET Stopwatch Objekt in PowerShell"></a></p><p>Man kann die Daten bestimmt auch noch besser und sinnvoller aufbereiten, aber f√ºr einfache Szenarien hat mir das so immer ausgereicht.</p><h2 id=weiterf√ºhrende-links>Weiterf√ºhrende Links<a hidden class=anchor aria-hidden=true href=#weiterf√ºhrende-links>#</a></h2><ul><li>PowerShell Cmdlet <code>Measure-Command</code>: <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-5.1" target=_blank>https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-5.1</a></li><li>.NET Klasse <code>StopWatch</code>: <a href="https://learn.microsoft.com/de-de/dotnet/api/system.diagnostics.stopwatch.startnew?view=netframework-4.8.1" target=_blank>https://learn.microsoft.com/de-de/dotnet/api/system.diagnostics.stopwatch.startnew?view=netframework-4.8.1</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://diecknet.de/de/tags/powershell/>Powershell</a></li><li><a href=https://diecknet.de/de/tags/measure/>Measure</a></li><li><a href=https://diecknet.de/de/tags/optimization/>Optimization</a></li><li><a href=https://diecknet.de/de/tags/timespan/>Timespan</a></li></ul><div class=share-buttons></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://diecknet.de/de/>diecknet</a></span>
&nbsp;|&nbsp;
<span><a href=https://diecknet.de/de/legal/>Impressum</a>
</span>&nbsp;|&nbsp;<span>
<a href=https://diecknet.de/de/privacy/>Datenschutz</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Kopieren";function s(){t.innerHTML="Kopiert!",setTimeout(()=>{t.innerHTML="Kopieren"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script type=text/javascript>var _paq=window._paq||[];_paq.push(["disableCookies"]),_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){t="//nc.diecknet.de/mt/",_paq.push(["setTrackerUrl",t+"mdata"]),_paq.push(["setSiteId","1"]);var t,n=document,e=n.createElement("script"),s=n.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.defer=!0,e.src=t+"m.js",s.parentNode.insertBefore(e,s)}()</script><noscript><p><img src="https://nc.diecknet.de/mt/mdata?idsite=1&amp;rec=1" style=border:0 alt></p></noscript></body></html>