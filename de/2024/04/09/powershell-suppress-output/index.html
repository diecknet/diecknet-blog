<!doctype html><html lang=de dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PowerShell Ausgabe unterdrücken | diecknet</title>
<meta name=keywords content="powershell"><meta name=description content='Manchmal geben PowerShell Befehle eine Rückmeldung aus, obwohl uns das gar nicht interessiert. Es gibt verschiedene Szenarien, wie ihr die Ausgaben unterdrücken könnt. Ich verwende hier zum Beispiel das Cmdlet New-NetFirewallRule mit dem ich eine neue Regel in der Windows Firewall hinzufügen kann:
1 New-NetFirewallRule -DisplayName "Ausgehende Verbindungen zu Port 443 blockieren" -Direction Outbound -RemotePort 443 -Protocol TCP -Action Block Wenn ich das ausführe, dann kriege ich als Rückgabe ein Objekt, welches die Firewall Regel repräsentiert.'><meta name=author content="Andreas Dieckmann"><link rel=canonical href=https://diecknet.de/de/2024/04/09/powershell-suppress-output/><link crossorigin=anonymous href=/assets/css/stylesheet.75a517428f403193483801122d6350f6956c3bb6bf5c6504311f8c24e6bab3e7.css integrity="sha256-daUXQo9AMZNIOAESLWNQ9pVsO7a/XGUEMR+MJOa6s+c=" rel="preload stylesheet" as=style><link rel=icon href=https://diecknet.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diecknet.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diecknet.de/favicon-32x32.png><link rel=apple-touch-icon href=https://diecknet.de/apple-touch-icon.png><link rel=mask-icon href=https://diecknet.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=de href=https://diecknet.de/de/2024/04/09/powershell-suppress-output/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="PowerShell Ausgabe unterdrücken"><meta property="og:description" content='Manchmal geben PowerShell Befehle eine Rückmeldung aus, obwohl uns das gar nicht interessiert. Es gibt verschiedene Szenarien, wie ihr die Ausgaben unterdrücken könnt. Ich verwende hier zum Beispiel das Cmdlet New-NetFirewallRule mit dem ich eine neue Regel in der Windows Firewall hinzufügen kann:
1 New-NetFirewallRule -DisplayName "Ausgehende Verbindungen zu Port 443 blockieren" -Direction Outbound -RemotePort 443 -Protocol TCP -Action Block Wenn ich das ausführe, dann kriege ich als Rückgabe ein Objekt, welches die Firewall Regel repräsentiert.'><meta property="og:type" content="article"><meta property="og:url" content="https://diecknet.de/de/2024/04/09/powershell-suppress-output/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-09T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PowerShell Ausgabe unterdrücken"><meta name=twitter:description content='Manchmal geben PowerShell Befehle eine Rückmeldung aus, obwohl uns das gar nicht interessiert. Es gibt verschiedene Szenarien, wie ihr die Ausgaben unterdrücken könnt. Ich verwende hier zum Beispiel das Cmdlet New-NetFirewallRule mit dem ich eine neue Regel in der Windows Firewall hinzufügen kann:
1 New-NetFirewallRule -DisplayName "Ausgehende Verbindungen zu Port 443 blockieren" -Direction Outbound -RemotePort 443 -Protocol TCP -Action Block Wenn ich das ausführe, dann kriege ich als Rückgabe ein Objekt, welches die Firewall Regel repräsentiert.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://diecknet.de/de/posts/"},{"@type":"ListItem","position":2,"name":"PowerShell Ausgabe unterdrücken","item":"https://diecknet.de/de/2024/04/09/powershell-suppress-output/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PowerShell Ausgabe unterdrücken","name":"PowerShell Ausgabe unterdrücken","description":"Manchmal geben PowerShell Befehle eine Rückmeldung aus, obwohl uns das gar nicht interessiert. Es gibt verschiedene Szenarien, wie ihr die Ausgaben unterdrücken könnt. Ich verwende hier zum Beispiel das Cmdlet New-NetFirewallRule mit dem ich eine neue Regel in der Windows Firewall hinzufügen kann:\n1 New-NetFirewallRule -DisplayName \u0026#34;Ausgehende Verbindungen zu Port 443 blockieren\u0026#34; -Direction Outbound -RemotePort 443 -Protocol TCP -Action Block Wenn ich das ausführe, dann kriege ich als Rückgabe ein Objekt, welches die Firewall Regel repräsentiert.","keywords":["powershell"],"articleBody":"Manchmal geben PowerShell Befehle eine Rückmeldung aus, obwohl uns das gar nicht interessiert. Es gibt verschiedene Szenarien, wie ihr die Ausgaben unterdrücken könnt. Ich verwende hier zum Beispiel das Cmdlet New-NetFirewallRule mit dem ich eine neue Regel in der Windows Firewall hinzufügen kann:\n1 New-NetFirewallRule -DisplayName \"Ausgehende Verbindungen zu Port 443 blockieren\" -Direction Outbound -RemotePort 443 -Protocol TCP -Action Block Wenn ich das ausführe, dann kriege ich als Rückgabe ein Objekt, welches die Firewall Regel repräsentiert. Wenn man das in einem Skript weiterverarbeiten möchte ist es natürlich sinnvoll. Manchmal braucht man die Info aber nicht.\n$null vs. Out-Null Ich würde das jetzt am ehesten unterdrücken, indem ich die automatische vordefinierte Variable $null verwende und ihr die Rückgabe des Befehls zuweise. $null ist read-only, erhält dadurch also nicht wirklich einen anderen Wert zugewiesen.\n1 $null = New-NetFirewallRule -DisplayName \"Ausgehende Verbindungen zu Port 443 blockieren\" -Direction Outbound -RemotePort 443 -Protocol TCP -Action Block Eine Alternative dazu wäre, das Ergebnis des Befehls an das Cmdlet Out-Null zu pipen.\n1 New-NetFirewallRule -DisplayName \"Ausgehende Verbindungen zu Port 443 blockieren\" -Direction Outbound -RemotePort 443 -Protocol TCP -Action Block | Out-Null Ich habe die Erfahrung gemacht, dass die Zuweisung zu $null performanter arbeitet als das Pipen zu Out-Null. Das liegt daran, dass die Ausführung der Pipe immer eine Auswirkung auf die Performance hat. In manchen Fällen macht es keinen Unterschied, oder nur einen kleinen - in anderen Fällen ist es gravierender.\nBeides ist aber auf jeden schneller als das Objekt immer sichtbar auszugeben. Es kommt natürlich auch immer auf das Cmdlet und das ausgegebene Objekt an, aber bei mir war es reproduzierbar einige Millisekunden langsamer, wenn ich die erstellte Firewall-Regel sichtbar ausgeben lasse.\nFehler unterdrücken Es kann aber auch sein, dass euer Cmdlet Fehler ausgibt. Wenn euch die nicht interessieren und ihr einfach weiter machen wollt, dann könnt ihr probieren den Common Parameter -ErrorAction auf SilentlyContinue zu setzen.\n1 $null = New-Item C:\\diecknet\\Hallo\\Welt -Type Directory -ErrorAction SilentlyContinue Das funktioniert aber nicht mit allen Cmdlets und nicht mit allen Fehlern. Manche Fehler sind so gravierend, dass nicht einfach mit SilentlyContinue fortgefahren werden kann. In so einem Fall könnt ihr versuchen mit einem try-catch Konstrukt den Fehler abzufangen.\n1 2 3 4 5 6 7 8 9 \u003c# Grundsätzliches zu try-catch: Im try Block steht der Code, dessen Fehler abgefangen werden soll. Am besten möglichst wenig Code in den try Block schreiben, also quasi 1-2 Befehle die zusammengehören. Nicht aber das ganze Skript in einen Try-Block schreiben. #\u003e try { Dieser-Befehl-existiert-nicht } catch {} Normalerweise würde man den Fehler im catch Block versuchen abzumildern. Also irgendwelche Maßnahmen ergreifen die dafür sorgen, dass es nicht so schlimm ist, dass ein Fehler aufgetreten ist. Wenn es uns aber nur darum geht, eine Fehlerausgabe zu verhindern, dann können wir den catch Block auch leer lassen. Am besten natürlich kombiniert mit der Unterdrückung der regulären Ausgabe.\n1 2 3 try { $null = Dieser-Befehl-existiert-nicht } catch {} Alle Ausgaben unterdrücken In manchen Situationen gibt es aber auch noch mehr Ausgaben als die Standard Ausgabe oder vielleicht noch Fehlermeldungen. Die PowerShell hat nämlich einige weitere Output Streams.\nStream ID Beschreibung Verfügbar ab Write Cmdlet 1 Success Stream PowerShell 2.0 Write-Output 2 Error Stream PowerShell 2.0 Write-Error 3 Warning Stream PowerShell 2.0 Write-Warning 4 Verbose Stream PowerShell 2.0 Write-Verbose 5 Debug Stream PowerShell 2.0 Write-Debug 6 Information Stream PowerShell 5.0 Write-Information n/a Progress Stream PowerShell 2.0 Write-Progress Ich will jetzt hier nicht zu tief auf die einzelnen Output Streams eingehen, schaut dafür am besten das Video zu PowerShell Output Streams auf meinem YouTube Kanal an. Stattdessen zeige ich euch kurz und knapp wie ihr alle Output Streams unterdrücken könnt. Hier habe ich ein Beispiel Skript, welches in verschiedene Output Streams schreibt:\n1 2 3 4 5 6 7 8 9 10 11 12 # Filename: Multi-Output-Beispiel.ps1 function Get-MultipleOutputs { $DebugPreference = \"Continue\" $WarningPreference = \"Continue\" $VerbosePreference = \"Continue\" Write-Verbose \"Preference Variablen gesetzt.\" Write-Debug \"Hallöchen aus dem Debug Stream :)\" Write-Warning \"Ohje, ohje eine Warnung! Was sollen wir nur tun?\" Write-Verbose \"Beispiel-Ausgabe abgeschlossen...\" } Get-MultipleOutputs Um die Ausgabe von allen Output Streams zu verhindern, können wir an das Ende einer Zeile beziehungsweise eines Befehls *\u003e$null anhängen. Also das kann für folgende Fälle genutzt werden:\nEin ganzes Skript: .\\Multi-Output-Beispiel.ps1 *\u003e$null Einen einzelnen Befehl, also zum Beispiel ein Cmdlet: Get-MultipleOutputs *\u003e$null Und auch für native Commands also z.B. irgendwelche .exe Programme die in der Commandline/PowerShell ausgeführt werden können: ping localhost *\u003e$null Schlusswort Natürlich ist es oft besser die Rückgaben von Cmdlets zu beachten und im Code darauf zu reagieren. Dennoch gibt es Fälle, bei denen eine Ausgabe nicht notwendig ist. Wenn das bei euch mal der Fall sein sollte, dann wisst ihr jetzt wie ihr die Ausgabe unterdrücken könnt.\n","wordCount":"781","inLanguage":"de","datePublished":"2024-04-09T00:00:00Z","dateModified":"2024-04-09T00:00:00Z","author":{"@type":"Person","name":"Andreas Dieckmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diecknet.de/de/2024/04/09/powershell-suppress-output/"},"publisher":{"@type":"Organization","name":"diecknet","logo":{"@type":"ImageObject","url":"https://diecknet.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diecknet.de/de/ accesskey=h title="diecknet (Alt + H)">diecknet</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://diecknet.de/de/ title=Deutsch aria-label=Deutsch><b>Deutsch</b></a></li><li><a href=https://diecknet.de/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://diecknet.de/de/ title=Home><span>Home</span></a></li><li><a href=https://diecknet.de/de/about/ title=About><span>About</span></a></li><li><a href=https://diecknet.de/de/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://diecknet.de/de/archive/ title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://diecknet.de/de/>Home</a>&nbsp;»&nbsp;<a href=https://diecknet.de/de/posts/>Posts</a></div><h1 class=post-title>PowerShell Ausgabe unterdrücken</h1><div class=post-meta><span title='2024-04-09 00:00:00 +0000 UTC'>2024-04-09</span>&nbsp;·&nbsp;4 Minuten&nbsp;·&nbsp;Andreas Dieckmann&nbsp;|&nbsp;<a href=https://github.com/diecknet/diecknet-blog/tree/main/content/de/posts/2024/2024-04-09-PowerShell-Suppress-Output.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Inhaltsverzeichnis</span></summary><div class=inner><ul><li><a href=#null-vs-out-null aria-label="$null vs. Out-Null"><code>$null</code> vs. <code>Out-Null</code></a></li><li><a href=#fehler-unterdr%c3%bccken aria-label="Fehler unterdrücken">Fehler unterdrücken</a></li><li><a href=#alle-ausgaben-unterdr%c3%bccken aria-label="Alle Ausgaben unterdrücken">Alle Ausgaben unterdrücken</a></li><li><a href=#schlusswort aria-label=Schlusswort>Schlusswort</a></li></ul></div></details></div><div class=post-content><p>Manchmal geben PowerShell Befehle eine Rückmeldung aus, obwohl uns das gar nicht interessiert. Es gibt verschiedene Szenarien, wie ihr die Ausgaben unterdrücken könnt.
Ich verwende hier zum Beispiel das Cmdlet <code>New-NetFirewallRule</code> mit dem ich eine neue Regel in der Windows Firewall hinzufügen kann:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>New-NetFirewallRule</span> -DisplayName <span style=color:#fc6a5d>&#34;Ausgehende Verbindungen zu Port 443 blockieren&#34;</span> -Direction Outbound -RemotePort <span style=color:#d0bf69>443</span> -Protocol TCP -Action Block
</span></span></code></pre></td></tr></table></div></div><p><a href=/images/2024/2024-04-09_PowerShell_new-netfirewallrule_example.jpg><img loading=lazy src=/images/2024/2024-04-09_PowerShell_new-netfirewallrule_example.jpg alt="Beispiel für eine exzessive Rückgabe von Informationen durch ein PowerShell Cmdlet: Der Aufruf von New-NetFirewallRule" title="Beispiel für eine exzessive Rückgabe von Informationen durch ein PowerShell Cmdlet: Der Aufruf von New-NetFirewallRule"></a></p><p>Wenn ich das ausführe, dann kriege ich als Rückgabe ein Objekt, welches die Firewall Regel repräsentiert. Wenn man das in einem Skript weiterverarbeiten möchte ist es natürlich sinnvoll. Manchmal braucht man die Info aber nicht.</p><h2 id=null-vs-out-null><code>$null</code> vs. <code>Out-Null</code><a hidden class=anchor aria-hidden=true href=#null-vs-out-null>#</a></h2><p>Ich würde das jetzt am ehesten unterdrücken, indem ich die automatische vordefinierte Variable <code>$null</code> verwende und ihr die Rückgabe des Befehls zuweise. <code>$null</code> ist read-only, erhält dadurch also nicht wirklich einen anderen Wert zugewiesen.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$null = <span style=color:#d0a8ff>New-NetFirewallRule</span> -DisplayName <span style=color:#fc6a5d>&#34;Ausgehende Verbindungen zu Port 443 blockieren&#34;</span> -Direction Outbound -RemotePort <span style=color:#d0bf69>443</span> -Protocol TCP -Action Block
</span></span></code></pre></td></tr></table></div></div><p>Eine Alternative dazu wäre, das Ergebnis des Befehls an das Cmdlet <code>Out-Null</code> zu pipen.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>New-NetFirewallRule</span> -DisplayName <span style=color:#fc6a5d>&#34;Ausgehende Verbindungen zu Port 443 blockieren&#34;</span> -Direction Outbound -RemotePort <span style=color:#d0bf69>443</span> -Protocol TCP -Action Block | <span style=color:#d0a8ff>Out-Null</span>
</span></span></code></pre></td></tr></table></div></div><p><a href=/images/2024/2024-04-09_PowerShell_hide_output_example_1.jpg><img loading=lazy src=/images/2024/2024-04-09_PowerShell_hide_output_example_1.jpg alt="2 Möglichkeiten die Ausgabe eines PowerShell Befehls zu unterdrücken: Mit $null und Out-Null" title="2 Möglichkeiten die Ausgabe eines PowerShell Befehls zu unterdrücken: Mit $null und Out-Null"></a></p><p>Ich habe die Erfahrung gemacht, dass die Zuweisung zu <code>$null</code> performanter arbeitet als das Pipen zu <code>Out-Null</code>. Das liegt daran, dass die Ausführung der Pipe immer eine Auswirkung auf die Performance hat. In manchen Fällen macht es keinen Unterschied, oder nur einen kleinen - in anderen Fällen ist es gravierender.</p><p>Beides ist aber auf jeden schneller als das Objekt immer sichtbar auszugeben. Es kommt natürlich auch immer auf das Cmdlet und das ausgegebene Objekt an, aber bei mir war es reproduzierbar einige Millisekunden langsamer, wenn ich die erstellte Firewall-Regel sichtbar ausgeben lasse.</p><p><a href=/images/2024/2024-04-09_PowerShell_suppress-output-comparison.jpg><img loading=lazy src=/images/2024/2024-04-09_PowerShell_suppress-output-comparison.jpg alt="Messwerte von unterschiedlich unterdrückter Ausgabe und nicht-unterdrückter Ausgabe" title="Messwerte von unterschiedlich unterdrückter Ausgabe und nicht-unterdrückter Ausgabe"></a></p><h2 id=fehler-unterdrücken>Fehler unterdrücken<a hidden class=anchor aria-hidden=true href=#fehler-unterdrücken>#</a></h2><p>Es kann aber auch sein, dass euer Cmdlet Fehler ausgibt. Wenn euch die nicht interessieren und ihr einfach weiter machen wollt, dann könnt ihr probieren den Common Parameter <code>-ErrorAction</code> auf <code>SilentlyContinue</code> zu setzen.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$null = <span style=color:#d0a8ff>New-Item</span> C:\diecknet\Hallo\Welt -Type Directory -ErrorAction SilentlyContinue
</span></span></code></pre></td></tr></table></div></div><p>Das funktioniert aber nicht mit allen Cmdlets und nicht mit allen Fehlern. Manche Fehler sind so gravierend, dass nicht einfach mit <code>SilentlyContinue</code> fortgefahren werden kann. In so einem Fall könnt ihr versuchen mit einem <code>try-catch</code> Konstrukt den Fehler abzufangen.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986>&lt;# Grundsätzliches zu try-catch:
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Im try Block steht der Code, dessen Fehler abgefangen werden soll. 
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Am besten möglichst wenig Code in den try Block schreiben, also quasi 1-2
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Befehle die zusammengehören. Nicht aber das ganze Skript in einen Try-Block schreiben.
</span></span></span><span style=display:flex><span><span style=color:#6c7986>#&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc5fa3>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#d0a8ff>Dieser-Befehl</span>-existiert-nicht
</span></span><span style=display:flex><span>} <span style=color:#fc5fa3>catch</span> {}
</span></span></code></pre></td></tr></table></div></div><p>Normalerweise würde man den Fehler im <code>catch</code> Block versuchen abzumildern. Also irgendwelche Maßnahmen ergreifen die dafür sorgen, dass es nicht so schlimm ist, dass ein Fehler aufgetreten ist. Wenn es uns aber nur darum geht, eine Fehler<em>ausgabe</em> zu verhindern, dann können wir den <code>catch</code> Block auch leer lassen. Am besten natürlich kombiniert mit der Unterdrückung der regulären Ausgabe.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#fc5fa3>try</span> {
</span></span><span style=display:flex><span>    $null = <span style=color:#d0a8ff>Dieser-Befehl</span>-existiert-nicht
</span></span><span style=display:flex><span>} <span style=color:#fc5fa3>catch</span> {}
</span></span></code></pre></td></tr></table></div></div><h2 id=alle-ausgaben-unterdrücken>Alle Ausgaben unterdrücken<a hidden class=anchor aria-hidden=true href=#alle-ausgaben-unterdrücken>#</a></h2><p>In manchen Situationen gibt es aber auch noch mehr Ausgaben als die Standard Ausgabe oder vielleicht noch Fehlermeldungen. Die PowerShell hat nämlich einige weitere Output Streams.</p><table><thead><tr><th>Stream ID</th><th>Beschreibung</th><th>Verfügbar ab</th><th>Write Cmdlet</th></tr></thead><tbody><tr><td>1</td><td><strong>Success</strong> Stream</td><td>PowerShell 2.0</td><td><code>Write-Output</code></td></tr><tr><td>2</td><td><strong>Error</strong> Stream</td><td>PowerShell 2.0</td><td><code>Write-Error</code></td></tr><tr><td>3</td><td><strong>Warning</strong> Stream</td><td>PowerShell 2.0</td><td><code>Write-Warning</code></td></tr><tr><td>4</td><td><strong>Verbose</strong> Stream</td><td>PowerShell 2.0</td><td><code>Write-Verbose</code></td></tr><tr><td>5</td><td><strong>Debug</strong> Stream</td><td>PowerShell 2.0</td><td><code>Write-Debug</code></td></tr><tr><td>6</td><td><strong>Information</strong> Stream</td><td>PowerShell 5.0</td><td><code>Write-Information</code></td></tr><tr><td>n/a</td><td><strong>Progress</strong> Stream</td><td>PowerShell 2.0</td><td><code>Write-Progress</code></td></tr></tbody></table><p>Ich will jetzt hier nicht zu tief auf die einzelnen Output Streams eingehen, schaut dafür am besten das <a href="https://www.youtube.com/watch?v=tpzQA3F9O_s" target=_blank>Video zu PowerShell Output Streams auf meinem YouTube Kanal</a> an. Stattdessen zeige ich euch kurz und knapp wie ihr alle Output Streams unterdrücken könnt.
Hier habe ich ein Beispiel Skript, welches in verschiedene Output Streams schreibt:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Filename: Multi-Output-Beispiel.ps1</span>
</span></span><span style=display:flex><span><span style=color:#fc5fa3>function</span> <span style=color:#d0a8ff>Get-MultipleOutputs</span> {
</span></span><span style=display:flex><span>    <span style=color:#41a1c0>$DebugPreference</span> = <span style=color:#fc6a5d>&#34;Continue&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#41a1c0>$WarningPreference</span> = <span style=color:#fc6a5d>&#34;Continue&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#41a1c0>$VerbosePreference</span> = <span style=color:#fc6a5d>&#34;Continue&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#d0a8ff>Write-Verbose</span> <span style=color:#fc6a5d>&#34;Preference Variablen gesetzt.&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#d0a8ff>Write-Debug</span> <span style=color:#fc6a5d>&#34;Hallöchen aus dem Debug Stream :)&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#d0a8ff>Write-Warning</span> <span style=color:#fc6a5d>&#34;Ohje, ohje eine Warnung! Was sollen wir nur tun?&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#d0a8ff>Write-Verbose</span> <span style=color:#fc6a5d>&#34;Beispiel-Ausgabe abgeschlossen...&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-MultipleOutputs</span>
</span></span></code></pre></td></tr></table></div></div><p>Um die Ausgabe von allen Output Streams zu verhindern, können wir an das Ende einer Zeile beziehungsweise eines Befehls <code>*>$null</code> anhängen. Also das kann für folgende Fälle genutzt werden:</p><ul><li>Ein ganzes Skript: <code>.\Multi-Output-Beispiel.ps1 *>$null</code></li><li>Einen einzelnen Befehl, also zum Beispiel ein Cmdlet: <code>Get-MultipleOutputs *>$null</code></li><li>Und auch für native Commands also z.B. irgendwelche <code>.exe</code> Programme die in der Commandline/PowerShell ausgeführt werden können: <code>ping localhost *>$null</code></li></ul><h2 id=schlusswort>Schlusswort<a hidden class=anchor aria-hidden=true href=#schlusswort>#</a></h2><p>Natürlich ist es oft besser die Rückgaben von Cmdlets zu beachten und im Code darauf zu reagieren. Dennoch gibt es Fälle, bei denen eine Ausgabe nicht notwendig ist. Wenn das bei euch mal der Fall sein sollte, dann wisst ihr jetzt wie ihr die Ausgabe unterdrücken könnt.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://diecknet.de/de/tags/powershell/>Powershell</a></li></ul><div class=share-buttons></div></footer><script src=https://giscus.diecknet.de/client.js data-repo=diecknet/diecknet-blog data-repo-id="MDEwOlJlcG9zaXRvcnkyMDkzNDUzNzM=" data-category="Blog Discussions" data-category-id=MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyNjMwOTY0 data-mapping=specific data-term=powershell-suppress-output data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://diecknet.de/de/>diecknet</a></span>
&nbsp;|&nbsp;
<span><a href=https://diecknet.de/de/legal/>Impressum</a>
</span>&nbsp;|&nbsp;<span>
<a href=https://diecknet.de/de/privacy/>Datenschutz</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Kopieren";function s(){t.innerHTML="Kopiert!",setTimeout(()=>{t.innerHTML="Kopieren"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script type=text/javascript>var _paq=window._paq||[];_paq.push(["disableCookies"]),_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){t="//nc.diecknet.de/mt/",_paq.push(["setTrackerUrl",t+"mdata"]),_paq.push(["setSiteId","1"]);var t,n=document,e=n.createElement("script"),s=n.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.defer=!0,e.src=t+"m.js",s.parentNode.insertBefore(e,s)}()</script><noscript><p><img src="https://nc.diecknet.de/mt/mdata?idsite=1&amp;rec=1" style=border:0 alt></p></noscript></body></html>