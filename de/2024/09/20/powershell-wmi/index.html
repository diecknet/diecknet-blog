<!doctype html><html lang=de dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>WMI in PowerShell verwenden | diecknet</title>
<meta name=keywords content="powershell"><meta name=description content="WMI ist eine mächtige Schnittstelle um Windows Systeme zu verwalten. Dadurch ist der Zugriff auf Dinge möglich, für die es vielleicht sonst gar keine eigenen PowerShell Cmdlets gibt. Teilweise können wir so mehr Infos abrufen, als die Standard-Cmdlets liefern. Das geht sowohl lokal, als auch remote.
Deprecated: Die alten WMI Cmdlets
Es gibt ein paar ältere Cmdlets, die allerdings für Neuentwicklungen nicht empfohlen werden. Aber vielleicht stoßt ihr in älteren Skripten mal darüber, also jetzt habt ihr schon mal davon gehört - die existieren zumindest."><meta name=author content="Andreas Dieckmann"><link rel=canonical href=https://diecknet.de/de/2024/09/20/powershell-wmi/><link crossorigin=anonymous href=/assets/css/stylesheet.75a517428f403193483801122d6350f6956c3bb6bf5c6504311f8c24e6bab3e7.css integrity="sha256-daUXQo9AMZNIOAESLWNQ9pVsO7a/XGUEMR+MJOa6s+c=" rel="preload stylesheet" as=style><link rel=icon href=https://diecknet.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diecknet.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diecknet.de/favicon-32x32.png><link rel=apple-touch-icon href=https://diecknet.de/apple-touch-icon.png><link rel=mask-icon href=https://diecknet.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=de href=https://diecknet.de/de/2024/09/20/powershell-wmi/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="WMI in PowerShell verwenden"><meta property="og:description" content="WMI ist eine mächtige Schnittstelle um Windows Systeme zu verwalten. Dadurch ist der Zugriff auf Dinge möglich, für die es vielleicht sonst gar keine eigenen PowerShell Cmdlets gibt. Teilweise können wir so mehr Infos abrufen, als die Standard-Cmdlets liefern. Das geht sowohl lokal, als auch remote.
Deprecated: Die alten WMI Cmdlets
Es gibt ein paar ältere Cmdlets, die allerdings für Neuentwicklungen nicht empfohlen werden. Aber vielleicht stoßt ihr in älteren Skripten mal darüber, also jetzt habt ihr schon mal davon gehört - die existieren zumindest."><meta property="og:type" content="article"><meta property="og:url" content="https://diecknet.de/de/2024/09/20/powershell-wmi/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-20T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="WMI in PowerShell verwenden"><meta name=twitter:description content="WMI ist eine mächtige Schnittstelle um Windows Systeme zu verwalten. Dadurch ist der Zugriff auf Dinge möglich, für die es vielleicht sonst gar keine eigenen PowerShell Cmdlets gibt. Teilweise können wir so mehr Infos abrufen, als die Standard-Cmdlets liefern. Das geht sowohl lokal, als auch remote.
Deprecated: Die alten WMI Cmdlets
Es gibt ein paar ältere Cmdlets, die allerdings für Neuentwicklungen nicht empfohlen werden. Aber vielleicht stoßt ihr in älteren Skripten mal darüber, also jetzt habt ihr schon mal davon gehört - die existieren zumindest."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://diecknet.de/de/posts/"},{"@type":"ListItem","position":2,"name":"WMI in PowerShell verwenden","item":"https://diecknet.de/de/2024/09/20/powershell-wmi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"WMI in PowerShell verwenden","name":"WMI in PowerShell verwenden","description":"WMI ist eine mächtige Schnittstelle um Windows Systeme zu verwalten. Dadurch ist der Zugriff auf Dinge möglich, für die es vielleicht sonst gar keine eigenen PowerShell Cmdlets gibt. Teilweise können wir so mehr Infos abrufen, als die Standard-Cmdlets liefern. Das geht sowohl lokal, als auch remote.\nDeprecated: Die alten WMI Cmdlets Es gibt ein paar ältere Cmdlets, die allerdings für Neuentwicklungen nicht empfohlen werden. Aber vielleicht stoßt ihr in älteren Skripten mal darüber, also jetzt habt ihr schon mal davon gehört - die existieren zumindest.\n","keywords":["powershell"],"articleBody":"WMI ist eine mächtige Schnittstelle um Windows Systeme zu verwalten. Dadurch ist der Zugriff auf Dinge möglich, für die es vielleicht sonst gar keine eigenen PowerShell Cmdlets gibt. Teilweise können wir so mehr Infos abrufen, als die Standard-Cmdlets liefern. Das geht sowohl lokal, als auch remote.\nDeprecated: Die alten WMI Cmdlets Es gibt ein paar ältere Cmdlets, die allerdings für Neuentwicklungen nicht empfohlen werden. Aber vielleicht stoßt ihr in älteren Skripten mal darüber, also jetzt habt ihr schon mal davon gehört - die existieren zumindest.\n1 2 3 4 5 6 7 8 9 10 11 12 13 Get-Command -Noun WMI* \u003c# Ausgabe: CommandType Name Version Source ----------- ---- ------- ------ Cmdlet Get-WmiObject 3.1.0.0 Microsoft.PowerShell.Management Cmdlet Invoke-WmiMethod 3.1.0.0 Microsoft.PowerShell.Management Cmdlet Register-WmiEvent 3.1.0.0 Microsoft.PowerShell.Management Cmdlet Remove-WmiObject 3.1.0.0 Microsoft.PowerShell.Management Cmdlet Set-WmiInstance 3.1.0.0 Microsoft.PowerShell.Management #\u003e CIM Cmdlets Stattdessen macht es Sinn, bei Neuentwicklungen auf die CIM Cmdlets zu setzen. CIM steht für “Common Information Model” und ist quasi der eigentliche technische Standard. Und WMI ist die CIM Implementierung von Microsoft, die den Standard dann teilweise noch ein bisschen erweitert.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Get-Command -Module CimCmdlets \u003c# Ausgabe CommandType Name Version Source ----------- ---- ------- ------ Cmdlet Export-BinaryMiLog 1.0.0.0 CimCmdlets Cmdlet Get-CimAssociatedInstance 1.0.0.0 CimCmdlets Cmdlet Get-CimClass 1.0.0.0 CimCmdlets Cmdlet Get-CimInstance 1.0.0.0 CimCmdlets Cmdlet Get-CimSession 1.0.0.0 CimCmdlets Cmdlet Import-BinaryMiLog 1.0.0.0 CimCmdlets Cmdlet Invoke-CimMethod 1.0.0.0 CimCmdlets Cmdlet New-CimInstance 1.0.0.0 CimCmdlets Cmdlet New-CimSession 1.0.0.0 CimCmdlets Cmdlet New-CimSessionOption 1.0.0.0 CimCmdlets Cmdlet Register-CimIndicationEvent 1.0.0.0 CimCmdlets Cmdlet Remove-CimInstance 1.0.0.0 CimCmdlets Cmdlet Remove-CimSession 1.0.0.0 CimCmdlets Cmdlet Set-CimInstance 1.0.0.0 CimCmdlets #\u003e Auch wenn da nur im Namen nur CIM steht und nicht WMI - damit können wir auf WMI zugreifen.\nWMI Daten abfragen Es gibt verschiedene Möglichkeiten Infos per WMI abzufragen. Zum Beispiel mit der WMI Query Language kurz WQL - eine Art von SQL. Es gibt einfachere Wege um Infos per WMI abzufragen, aber WMI Queries wurden z.B. gerne in alten VB-Skripten verwendet, oder auch bei WMI Filtern für Gruppenrichtlinien. Wenn ihr also bereits einen WMI Query habt, dann könnt ihr den einfach in PowerShell weiterverwenden.\nEine Abfrage mit einem WMI Query könnt ihr mit dem Cmdlet Get-CimInstance ausführen.\n1 Get-CimInstance -Query \"Select * from Win32_BIOS\" Das bedeutet im Grunde: Zeige mir alle Eigenschaften von allen Instanzen der Klasse Win32_BIOS.\nEine etwas PowerShelligere Möglichkeit um WMI abzufragen, wäre so:\n1 Get-CimInstance -ClassName Win32_BIOS Bei beiden Varianten werden alle Eigenschaften zurückgeliefert - auch wenn das nicht sofort ersichtlich ist. Mit einer pipe zu | Select-Object * könnten alle Eigenschaften des zurückgelieferten Objekts sichtbar gemacht werden. Aber in der PowerShell gilt der Grundsatz: Wenn es möglich und sinnvoll ist, sollte soweit links wie es geht gefiltert werden. Das bezieht sich sowohl auf die Auswahl von Objekten, als auch auf die Auswahl der Objekteigenschaften. Für die Auswahl der Objekteigenschaften können wir den Parameter -Property verwenden. Also z.B.:\n1 Get-CimInstance -ClassName Win32_Bios -Property ReleaseDate Jetzt kann ich alles mögliche mit den abgerufenen Eigenschaften machen. Beispielsweise die Rückgabe in eine Variable laden oder direkt auf einzelne Eigenschaften der Rückgabe zugreifen.\n1 2 3 4 5 6 7 8 9 # WMI Daten in Variable ausgeben und die Variable ausgeben $BIOSInfos = Get-CimInstance -ClassName Win32_Bios -Property ReleaseDate $BiosInfos # WMI Daten in der Pipeline verarbeiten und nur die Eigenschaft \"ReleaseDate\" ausgeben Get-CimInstance -ClassName Win32_Bios -Property ReleaseDate | Select-Object -ExpandProperty ReleaseDate # WMI Daten inline in einem anderen Cmdlet abfragen und als Parameterwert verwenden New-TimeSpan -Start (Get-CimInstance -ClassName Win32_Bios -Property ReleaseDate).ReleaseDate -End (Get-Date) WMI Daten filtern Wenn ihr bei einer WMI Abfrage genauer filtern möchtet, dann geht das wahlweise mit einem kompletten WMI Query, oder mit dem -Filter Parameter. Die Syntax von WMI Filtern ist anders als sonst in PowerShell. Meiner Meinung nach eigentlich sogar ein bisschen intuitiver. Aber wenn man die ganze Zeit PowerShell verwendet, dann ist es doch wieder etwas ungewohnt.\nEs gibt die einfachen Vergleichsoperatoren:\nOperator Description = Equal to \u003c Less than \u003e Greater than \u003c= Less than or equal to \u003e= Greater than or equal to != or \u003c\u003e Not equal to Siehe dazu: https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-operators\nUnd auch den LIKE Operator für eine Platzhaltersuche. Siehe dazu: https://learn.microsoft.com/en-us/windows/win32/wmisdk/like-operator\n1 2 3 4 5 # Filtern mit Vergleichsoperator \"Equal to\" Get-CimInstance Win32_service -Filter \"Name = 'wuauserv'\" # Filtern mit LIKE Operator Get-CimInstance Win32_Service -Filter \"Caption LIKE 'Windows%'\" Mit WQL geht noch weitaus mehr, ich habe aber das bisher noch nicht wirklich gebraucht. Falls ihr euch dafür interessiert, schaut mal in die Dokumentation bei Microsoft: https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi\nVerknüpfte Instanzen Was auch noch hilfreich sein kann: Verknüpfte Klassen - beziehungsweise eigentlich asoziierte Instanzen. Zum Beispiel rufe ich mir erstmal alle physischen Netzwerkkarten an meinem Gerät ab:\n1 2 # Nur physische Netzwerkkarten abrufen: Get-CimInstance Win32_NetworkAdapter -Filter \"PhysicalAdapter = 1\" Anschließend pipe ich mir das in Get-CimAssociatedInstance um alle damit zusammenhängenden Instanzen zu sehen:\n1 Get-CimInstance Win32_NetworkAdapter -Filter \"PhysicalAdapter = 1\" | Get-CimAssociatedInstance Anhand der Daten die jetzt ausgegeben werden, kann ich vielleicht ja schon sehen, dass hier etwas interessantes vorliegt. Ansonsten können wir uns diese Ausgabe auch noch an Select-Object pipen, um z.B. nur die Namen der Klassen zu sehen:\n1 Get-CimInstance Win32_NetworkAdapter -Filter \"PhysicalAdapter = 1\" | Get-CimAssociatedInstance | Select-Object CimClass Oder um alle Eigenschaften zu sehen, die waren nämlich vorher nicht alle zu sehen:\n1 Get-CimInstance Win32_NetworkAdapter -Filter \"PhysicalAdapter = 1\" | Get-CimAssociatedInstance | Select-Object * Wenn wir dadurch herausgefunden haben, dass uns eine bestimmte Klasse interessiert, dann können wir unseren ursprünglichen Abruf von Get-CimAssociatedInstance anpassen und nur noch diese eine Klasse dadurch abrufen:\n1 Get-CimInstance Win32_NetworkAdapter -Filter \"PhysicalAdapter = 1\" | Get-CimAssociatedInstance -ResultClassName Win32_NetworkAdapterConfiguration Dadurch konnte ich mir jetzt die Netzwerkkonfiguration für eine bestimmte Netzwerkkarte in meinem Computer anzeigen lassen.\nRemote WMI Am einfachsten geht Remote WMI, wenn unser aktuell angemeldeter User auch Admin-Rechte auf dem Remote System hat. Zum Beispiel:\n1 Get-CimInstance -ClassName Win32_Desktop -ComputerName CL5 Alternativ können wir eine separate CimSession aufbauen und dabei dann andere Zugangsdaten angeben.\n1 2 3 4 5 6 7 # Credentials abfragen $Credential = Get-Credential # CIM Session aufbauen $CimSession = New-CimSession -ComputerName CL5 -Credential $Credential # CIM/WMI Abfrage ausführen Get-CimInstance -ClassName Win32_Desktop -CimSession $CimSession | Select-Object Name,Wallpaper Wenn ihr mehrere WMI Aktionen gegen ein Remote System ausführen wollt, dann ist es übrigens effizienter, erstmal eine Session aufzubauen und dann die ganzen Befehle mit dem -CimSession Parameter auszuführen. Wenn bei Get-CimInstance der -ComputerName Parameter genutzt wird, dann wird nämlich jedes mal neu eine Verbindung aufgebaut, sich authentifiziert, der Befehl ausgeführt und am Ende die Verbindung beendet. Eine CimSession hingegen besteht weiter, bis sie aktiv beendet wird.\nWSMAN und DCOM WMI Remoting mit den CIM Befehlen verwendet im Hintergrund standardmäßig das WSMAN Protokoll. Falls Remote WMI bei euch noch nicht direkt funktioniert, dann könnt ihr es mit dem Cmdlet Enable-PSRemoting aktivieren. Die älteren WMI-Cmdlets verwenden übrigens DCOM statt WSMAN, was aber unter modernen Systemen im Standard von der Windows Firewall blockiert wird. Es wäre aber auch mit den CIM-Cmdlets möglich DCOM zu verwenden, falls es nötig ist. Die Details dazu findet ihr bei Microsoft Learn.\nMehrere Remote Systeme Es ist auch möglich mit mehreren remote Systemen aufeinmal zu arbeiten. Dazu müsst ihr zunächst einmal mehrere CimSessions aufbauen, und sie dann an Get-CimInstance übergeben.\n1 2 3 4 $CimSession1 = New-CimSession -ComputerName CL5 -Credential (Get-Credential) $CimSession2 = New-CimSession -ComputerName DC2 -Credential (Get-Credential) Get-CimInstance -ClassName Win32_Desktop -CimSession $CimSession1,$CimSession2 | Select-Object Name,Wallpaper Verbindung trennen Wenn ihr eure Remotetätigkeiten abgeschlossen habt, dann solltet ihr auch die Verbindungen wieder trennen. Am einfachsten geht das per:\n1 Get-CimSession | Remove-CimSession WMI Methoden ausführen Mit WMI können wir aber nicht nur Infos abrufen, sondern auch Methoden ausführen. Teilweise überschneiden die sich inhaltlich auch mit normalen PowerShell Cmdlets oder mit Methoden die per .NET verfügbar sind. Es kann aber auch sein, dass genau die Sache die ihr machen wollt, nur per WMI verfügbar ist.\nZum Beispiel rufe ich mir erstmal eine CIM Instanz ab, die sich auf einen bestimmten Drucker bezieht. Anschließend pipe ich die Instanz an Invoke-CimMethod um den Drucker als Standarddrucker zu definieren.\n1 2 # Standarddrucker per WMI setzen: Mit 2 Cmdlets Get-CimInstance -ClassName Win32_Printer -Filter \"Name = 'Microsoft XPS Document Writer'\" | Invoke-CimMethod -MethodName SetDefaultPrinter Ich musste jetzt hier zwei Cmdlets verwenden, weil Invoke-CimMethod nicht den -Filter Parameter unterstützt, der bei Get-CimInstance verfügbar ist. Ich könnte aber den -Query Parameter verwenden und einen WMI Query angeben, das hingegen wird von Invoke-CimMethod unterstützt.\n1 2 # Standarddrucker per WMI setzen: Nur 1 Cmdlet Invoke-CimMethod -Query \"SELECT * FROM Win32_Printer WHERE Name = 'Microsoft XPS Document Writer'\" -MethodName SetDefaultPrinter Es muss aber auch nicht unbedingt eine bestimmte WMI Objektinstanz angesprochen werden. Einige Klassen unterstützen auch direkte Methodenaufrufe. Zum Beispiel:\n1 2 # Prozess starten per WMI Invoke-CimMethod -ClassName Win32_Process -MethodName \"Create\" -Arguments @{CommandLine = 'notepad.exe'} WMI Remote Methodenaufrufe Grundsätzlich unterstützt Invoke-CimMethod auch das zuvor gezeigte Remoting. Also auch hier könnte wahlweise -ComputerName oder -CimSession verwendet werden.\n1 2 3 # Beispiel für einen remote WMI Methodenaufruf $MeineSession = New-CimSession -Credential (Get-Credential) -ComputerName dc2 Invoke-CimMethod -ClassName Win32_Process -MethodName \"Create\" -Arguments @{CommandLine = 'notepad.exe'} -CimSession $MeineSession Wichtig: Wenn Prozesse remote gestartet werden, laufen die nicht sichtbar auf dem Desktop. Im Task Manager, oder zum Beispiel per Get-Process könnte man erkennen, dass die Prozesse laufen. Für das Beispiel notepad.exe ist das vielleicht nicht so sinnvoll, für andere Prozesse aber schon ✌️\nWMI Methoden herausfinden Wenn ihr schon eine WMI-Objektinstanz habt, dann könnt ihr direkt in der PowerShell schauen, welche Methoden zur Verfügung stehen:\n1 2 3 4 5 6 7 8 9 # Laufende notepad.exe Prozesse per WMI finden: $MeineCIMInstanz = Get-CimInstance Win32_Process -Filter \"Name = 'notepad.exe'\" # Mit Get-Member können wir die leider NICHT sehen, # da sie nicht als direkte Objektmethoden in PowerShell zur Verfügung stehen $MeineCIMInstanz | Get-Member # Stattdessen können wir auf die Eigenschaft CimClass.CimClassMehotds zugreifen $MeineCIMInstanz.CimClass.CimClassMethods WMI Objektinstanzen löschen Es gibt auch noch das Cmdlet Remove-CimInstance mit der WMI Objektinstanzen gelöscht werden können. Das ist in der Regel ein ⚠️ destruktiver Vorgang ⚠️, bei dem nicht einfach nur die Repräsentation des Objekts in der PowerShell entfernt wird, sondern das tatsächliche dahinterliegende Objekt wird zerstört. Also z.B. wenn ich die Objektinstanz eines laufenden Prozesses lösche, dann wird der Prozess beendet.\n1 2 3 4 5 # Laufende notepad.exe Prozesse per WMI finden: Get-CimInstance Win32_Process -Filter \"name = 'notepad.exe'\" # Laufende notepad.exe Prozesse per WMI finden UND BEENDEN: Get-CimInstance Win32_Process -Filter \"name = 'notepad.exe'\" | Remove-CimInstance Was genau passiert, kommt natürlich auf die konkrete Klasse an. Aber am besten verwendet ihr das Remove-CimInstance Cmdlet mit äußerster Vorsicht.\nWMI Klassen, Eigenschaften und Methoden herausfinden Um alle WMI Klassen aufzulisten, die es am System gibt, könnt ihr das Cmdlet Get-CimClass verwenden. Je nach System sind das auch unterschiedlich viele, aber auf einem modernen Windows 11 System locker über 2000. Und die ein oder andere Hard- oder Software bringt noch eigene Klassen mit.\n1 2 3 4 5 # Klassen auflisten Get-CimClass # Klassen zählen Get-CimClass | Measure-Object Zu den Namen der Klassen:\nFängt mit __ an: Systemklasse Fängt mit MSFT an: Systemklasse Fängt mit CIM an: Basis CIM Klasse (meist gibt es eine bessere Win32 Klasse als Alternative) ⭐ Fängt mit Win32 an: Erweiterte WMI Klasse (basiert auf CIM Standard-Klassen) Fängt mit Win32_Perf an: Performance Counter Klasse Fängt mit Win32_PnPDevice an: Plug and Play Device Klasse ⭐ Fängt komplett anders an: Könnte auch interessant sein Siehe dazu auch: https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-classes\nEs gibt teilweise CIM und Win32 Klassen die sich inhaltlich überschneiden. In der Regel ist die Win32 Klasse dann mächtiger. Zum Beispiel hat die Klasse Win32_Process bei mir 45 Properties und 7 Methoden, im Gegensatz zur CIM_Process Klasse, die nur 18 Properties und gar keine Methoden hat.\nDie Methoden und Eigenschaften einer Klasse sind in den Eigenschaften CimClassMethods und CimClassProperties aufgeführt.\n1 2 3 4 5 6 7 # Eigenschaften und Methoden der CIM_Process Klasse zählen: Get-CimClass -ClassName Cim_Process | Select-Object -ExpandProperty CimClassProperties | Measure-Object Get-CimClass -ClassName Cim_Process | Select-Object -ExpandProperty CimClassMethods | Measure-Object # Eigenschaften und Methoden der Win32_Process Klasse zählen: Get-CimClass -ClassName Win32_Process | Select-Object -ExpandProperty CimClassProperties | Measure-Object Get-CimClass -ClassName Win32_Process | Select-Object -ExpandProperty CimClassMethods | Measure-Object Ich bevorzuge es aber, mir die Infos in der offiziellen Dokumentation anzuschauen. Wenn ich einfach nach Win32_Process in einer Suchmaschine suche, dann lande ich schnell bei der richtigen Dokumentation. Vorteil ist: Dort gibt es in der Regel auch Beschreibungen und Beispiele für die Eigenschaften und Methoden.\nWMI Namespaces Wie euch vielleicht bei der Rückgabe von Get-CimClass aufgefallen ist: Über der Liste der Ergebnisse steht noch: “NameSpace: ROOT/cimv2”.\nDie Klassen sind in sogenannten Namespaces einsortiert - so ähnlich wie Ordner im Dateisystem. Zusätzliche Hard- oder Softwares bringen teilweise eigene Namespaces mit, in denen dann zusätzliche WMI Klassen drin sind. root/cimv2 ist einfach der Standard Namespace von Windows. Und wenn wir Get-CimClass ohne weitere Parameter aufrufen, dann werden uns nur die Klassen in diesem Standard Namespace aufgelistet. Es gibt aber noch mehr Namespaces. Die Definition der Namespaces kann ich über die System Klasse __Namespace abrufen, muss aber auch mit angeben, dass ich diese Definition im Namespace root ansehen möchte (ohne cimv2, das ist nämlich schon ein Unter-Namespace von root):\n1 Get-CimInstance __NAMESPACE -Namespace root Auf einem Domänencontroller habe ich auch schon andere Namespaces als auf einem Windows 11 Client. Zum Beispiel gibt es auf meinem DC den Namespace MicrosoftActiveDirectory.\n1 2 # Infos zur Klasse MicrosoftActiveDirectory im Namespace root abrufen: Get-CimClass -Namespace root/MicrosoftActiveDirectory Tatsächlich können Namespaces auch noch weitere Namespaces enthalten. Zum Beispiel sind im Standard Namespace root/cimv2 auch noch weitere Unter-Namespaces vorhanden. Mit einer kleinen selbstgeschriebenen Funktion können wir uns alle Namespaces auflisten.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function Get-CimNamespace { # Funktion um CIM Namespaces rekursiv abzurufen param($NameSpace = \"root\") foreach($thisNamespace in (Get-CimInstance __NAMESPACE -Namespace $NameSpace)) { ($SubNameSpace = \"{0}\\{1}\" -f $NameSpace,$thisNamespace.Name) # this line sets the var and also outputs it ;) Get-CimNamespace -NameSpace $SubNameSpace } } # Alle Namespaces in eine Variable laden $AllCimNameSpaces = Get-CimNamespace \"Found $($AllCimNameSpaces.Count) NameSpaces.\" $AllCimNameSpaces # Alle Klassen aus allen Namespaces abrufen: $AllCimClasses = $AllCimNameSpaces | ForEach-Object { Get-CimClass -Namespace $_ } \"Found $($AllCimClasses.Count) Classes:\" $AllCimClasses # Doppelte Klassen herausfiltern und das Ergebnis zählen: $AllCimClasses | Sort-Object -Property CimClassName -Unique | Measure-Object Generell spielt sich - meiner Meinung nach - aber auch viel wichtiges in dem Standard Namespace root/cimv2 ab. Aber das kommt natürlich darauf an, was ihr mit WMI gerade machen wollt.\nWMI Klassen finden Falls ihr noch nicht wisst, welche Klasse ihr braucht, könnt ihr mit Get-CimClass auch suchen. Wenn ihr vermutet, dass der Name der Klasse ein bestimmtes Wort enthält, könnt ihr Wildcards verwenden und suchen:\n1 2 3 4 5 6 7 8 9 10 # Suche nach WMI/CIM Klassen die \"process\" im Namen haben Get-CimClass -ClassName *process* # Suche nach WMI/CIM Klassen, bei denen es eine Methode gibt, # die \"reboot\" im Namen hat Get-CimClass -MethodName *reboot* # Suche nach WMI/CIM Klassen, bei denen es eine Property gibt, # die \"wallpaper\" im Namen hat Get-CimClass -PropertyName *wallpaper* Ansonsten gibt es auch noch grafische Tools die dabei helfen können, wie z.B. den WMI Explorer von Vinay Pamnani.\n","wordCount":"2507","inLanguage":"de","datePublished":"2024-09-20T00:00:00Z","dateModified":"2024-09-20T00:00:00Z","author":{"@type":"Person","name":"Andreas Dieckmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diecknet.de/de/2024/09/20/powershell-wmi/"},"publisher":{"@type":"Organization","name":"diecknet","logo":{"@type":"ImageObject","url":"https://diecknet.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diecknet.de/de/ accesskey=h title="diecknet (Alt + H)">diecknet</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://diecknet.de/de/ title=Deutsch aria-label=Deutsch><b>Deutsch</b></a></li><li><a href=https://diecknet.de/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://diecknet.de/de/ title=Home><span>Home</span></a></li><li><a href=https://diecknet.de/de/services/ title=Services><span>Services</span></a></li><li><a href=https://diecknet.de/de/about/ title=About><span>About</span></a></li><li><a href=https://diecknet.de/de/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://diecknet.de/de/archive/ title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://diecknet.de/de/>Home</a>&nbsp;»&nbsp;<a href=https://diecknet.de/de/posts/>Posts</a></div><h1 class=post-title>WMI in PowerShell verwenden</h1><div class=post-meta><span title='2024-09-20 00:00:00 +0000 UTC'>2024-09-20</span>&nbsp;·&nbsp;12 Minuten&nbsp;·&nbsp;Andreas Dieckmann&nbsp;|&nbsp;<a href=https://github.com/diecknet/diecknet-blog/tree/main/content/de/posts/2024/2024-09-20-PowerShell-WMI.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Inhaltsverzeichnis</span></summary><div class=inner><ul><li><a href=#deprecated-die-alten-wmi-cmdlets aria-label="Deprecated: Die alten WMI Cmdlets">Deprecated: Die alten WMI Cmdlets</a></li><li><a href=#cim-cmdlets aria-label="CIM Cmdlets">CIM Cmdlets</a></li><li><a href=#wmi-daten-abfragen aria-label="WMI Daten abfragen">WMI Daten abfragen</a></li><li><a href=#wmi-daten-filtern aria-label="WMI Daten filtern">WMI Daten filtern</a></li><li><a href=#verkn%c3%bcpfte-instanzen aria-label="Verknüpfte Instanzen">Verknüpfte Instanzen</a></li><li><a href=#remote-wmi aria-label="Remote WMI">Remote WMI</a><ul><li><a href=#wsman-und-dcom aria-label="WSMAN und DCOM">WSMAN und DCOM</a></li><li><a href=#mehrere-remote-systeme aria-label="Mehrere Remote Systeme">Mehrere Remote Systeme</a></li><li><a href=#verbindung-trennen aria-label="Verbindung trennen">Verbindung trennen</a></li></ul></li><li><a href=#wmi-methoden-ausf%c3%bchren aria-label="WMI Methoden ausführen">WMI Methoden ausführen</a><ul><li><a href=#wmi-remote-methodenaufrufe aria-label="WMI Remote Methodenaufrufe">WMI Remote Methodenaufrufe</a></li><li><a href=#wmi-methoden-herausfinden aria-label="WMI Methoden herausfinden">WMI Methoden herausfinden</a></li></ul></li><li><a href=#wmi-objektinstanzen-l%c3%b6schen aria-label="WMI Objektinstanzen löschen">WMI Objektinstanzen löschen</a></li><li><a href=#wmi-klassen-eigenschaften-und-methoden-herausfinden aria-label="WMI Klassen, Eigenschaften und Methoden herausfinden">WMI Klassen, Eigenschaften und Methoden herausfinden</a><ul><li><a href=#wmi-namespaces aria-label="WMI Namespaces">WMI Namespaces</a></li><li><a href=#wmi-klassen-finden aria-label="WMI Klassen finden">WMI Klassen finden</a></li></ul></li></ul></div></details></div><div class=post-content><p>WMI ist eine mächtige Schnittstelle um Windows Systeme zu verwalten. Dadurch ist der Zugriff auf Dinge möglich, für die es vielleicht sonst gar keine eigenen PowerShell Cmdlets gibt. Teilweise können wir so mehr Infos abrufen, als die Standard-Cmdlets liefern. Das geht sowohl lokal, als auch remote.</p><h2 id=deprecated-die-alten-wmi-cmdlets>Deprecated: Die alten WMI Cmdlets<a hidden class=anchor aria-hidden=true href=#deprecated-die-alten-wmi-cmdlets>#</a></h2><p>Es gibt ein paar ältere Cmdlets, die allerdings für Neuentwicklungen nicht empfohlen werden. Aber vielleicht stoßt ihr in älteren Skripten mal darüber, also jetzt habt ihr schon mal davon gehört - die existieren zumindest.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-Command</span> -Noun WMI*
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986>&lt;# Ausgabe:
</span></span></span><span style=display:flex><span><span style=color:#6c7986>
</span></span></span><span style=display:flex><span><span style=color:#6c7986>CommandType     Name                                               Version    Source
</span></span></span><span style=display:flex><span><span style=color:#6c7986>-----------     ----                                               -------    ------
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Get-WmiObject                                      3.1.0.0    Microsoft.PowerShell.Management
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Invoke-WmiMethod                                   3.1.0.0    Microsoft.PowerShell.Management
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Register-WmiEvent                                  3.1.0.0    Microsoft.PowerShell.Management
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Remove-WmiObject                                   3.1.0.0    Microsoft.PowerShell.Management
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Set-WmiInstance                                    3.1.0.0    Microsoft.PowerShell.Management
</span></span></span><span style=display:flex><span><span style=color:#6c7986>
</span></span></span><span style=display:flex><span><span style=color:#6c7986>#&gt;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=cim-cmdlets>CIM Cmdlets<a hidden class=anchor aria-hidden=true href=#cim-cmdlets>#</a></h2><p>Stattdessen macht es Sinn, bei Neuentwicklungen auf die CIM Cmdlets zu setzen. CIM steht für &ldquo;Common Information Model&rdquo; und ist quasi der eigentliche technische Standard. Und WMI ist die CIM Implementierung von Microsoft, die den Standard dann teilweise noch ein bisschen erweitert.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-Command</span> -Module CimCmdlets
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986>&lt;# Ausgabe
</span></span></span><span style=display:flex><span><span style=color:#6c7986>
</span></span></span><span style=display:flex><span><span style=color:#6c7986>CommandType     Name                                               Version    Source
</span></span></span><span style=display:flex><span><span style=color:#6c7986>-----------     ----                                               -------    ------
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Export-BinaryMiLog                                 1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Get-CimAssociatedInstance                          1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Get-CimClass                                       1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Get-CimInstance                                    1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Get-CimSession                                     1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Import-BinaryMiLog                                 1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Invoke-CimMethod                                   1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          New-CimInstance                                    1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          New-CimSession                                     1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          New-CimSessionOption                               1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Register-CimIndicationEvent                        1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Remove-CimInstance                                 1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Remove-CimSession                                  1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>Cmdlet          Set-CimInstance                                    1.0.0.0    CimCmdlets
</span></span></span><span style=display:flex><span><span style=color:#6c7986>
</span></span></span><span style=display:flex><span><span style=color:#6c7986>#&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>Auch wenn da nur im Namen nur CIM steht und nicht WMI - damit können wir auf WMI zugreifen.</p><h2 id=wmi-daten-abfragen>WMI Daten abfragen<a hidden class=anchor aria-hidden=true href=#wmi-daten-abfragen>#</a></h2><p>Es gibt verschiedene Möglichkeiten Infos per WMI abzufragen. Zum Beispiel mit der WMI Query Language kurz WQL - eine Art von SQL. Es gibt <em>einfachere</em> Wege um Infos per WMI abzufragen, aber WMI Queries wurden z.B. gerne in alten VB-Skripten verwendet, oder auch bei WMI Filtern für Gruppenrichtlinien. Wenn ihr also bereits einen WMI Query habt, dann könnt ihr den einfach in PowerShell weiterverwenden.</p><p>Eine Abfrage mit einem WMI Query könnt ihr mit dem Cmdlet <code>Get-CimInstance</code> ausführen.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> -Query <span style=color:#fc6a5d>&#34;Select * from Win32_BIOS&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Das bedeutet im Grunde: Zeige mir alle Eigenschaften von allen Instanzen der Klasse <code>Win32_BIOS</code>.</p><p>Eine etwas PowerShelligere Möglichkeit um WMI abzufragen, wäre so:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> -ClassName Win32_BIOS
</span></span></code></pre></td></tr></table></div></div><p>Bei beiden Varianten werden alle Eigenschaften zurückgeliefert - auch wenn das nicht sofort ersichtlich ist. Mit einer pipe zu <code>| Select-Object *</code> könnten alle Eigenschaften des zurückgelieferten Objekts sichtbar gemacht werden. Aber in der PowerShell gilt der Grundsatz: Wenn es möglich und sinnvoll ist, sollte soweit links wie es geht gefiltert werden. Das bezieht sich sowohl auf die Auswahl von Objekten, als auch auf die Auswahl der Objekteigenschaften.
Für die Auswahl der Objekteigenschaften können wir den Parameter <code>-Property</code> verwenden. Also z.B.:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> -ClassName Win32_Bios -Property ReleaseDate
</span></span></code></pre></td></tr></table></div></div><p>Jetzt kann ich alles mögliche mit den abgerufenen Eigenschaften machen. Beispielsweise die Rückgabe in eine Variable laden oder direkt auf einzelne Eigenschaften der Rückgabe zugreifen.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># WMI Daten in Variable ausgeben und die Variable ausgeben</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$BIOSInfos</span> = <span style=color:#d0a8ff>Get-CimInstance</span> -ClassName Win32_Bios -Property ReleaseDate
</span></span><span style=display:flex><span><span style=color:#41a1c0>$BiosInfos</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># WMI Daten in der Pipeline verarbeiten und nur die Eigenschaft &#34;ReleaseDate&#34; ausgeben</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> -ClassName Win32_Bios -Property ReleaseDate | <span style=color:#d0a8ff>Select-Object</span> -ExpandProperty ReleaseDate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># WMI Daten inline in einem anderen Cmdlet abfragen und als Parameterwert verwenden</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>New-TimeSpan</span> -Start (<span style=color:#d0a8ff>Get-CimInstance</span> -ClassName Win32_Bios -Property ReleaseDate).ReleaseDate -End (<span style=color:#d0a8ff>Get-Date</span>)
</span></span></code></pre></td></tr></table></div></div><h2 id=wmi-daten-filtern>WMI Daten filtern<a hidden class=anchor aria-hidden=true href=#wmi-daten-filtern>#</a></h2><p>Wenn ihr bei einer WMI Abfrage genauer filtern möchtet, dann geht das wahlweise mit einem kompletten WMI Query, oder mit dem <code>-Filter</code> Parameter. Die Syntax von WMI Filtern ist anders als sonst in PowerShell. Meiner Meinung nach eigentlich sogar ein bisschen intuitiver. Aber wenn man die ganze Zeit PowerShell verwendet, dann ist es doch wieder etwas ungewohnt.</p><p>Es gibt die einfachen Vergleichsoperatoren:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>=</td><td>Equal to</td></tr><tr><td>&lt;</td><td>Less than</td></tr><tr><td>></td><td>Greater than</td></tr><tr><td>&lt;=</td><td>Less than or equal to</td></tr><tr><td>>=</td><td>Greater than or equal to</td></tr><tr><td>!= or &lt;></td><td>Not equal to</td></tr></tbody></table><p>Siehe dazu: <a href=https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-operators target=_blank>https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-operators</a></p><p>Und auch den <code>LIKE</code> Operator für eine Platzhaltersuche. Siehe dazu: <a href=https://learn.microsoft.com/en-us/windows/win32/wmisdk/like-operator target=_blank>https://learn.microsoft.com/en-us/windows/win32/wmisdk/like-operator</a></p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Filtern mit Vergleichsoperator &#34;Equal to&#34; </span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> Win32_service -Filter <span style=color:#fc6a5d>&#34;Name = &#39;wuauserv&#39;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Filtern mit LIKE Operator</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> Win32_Service -Filter <span style=color:#fc6a5d>&#34;Caption LIKE &#39;Windows%&#39;&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Mit WQL geht noch weitaus mehr, ich habe aber das bisher noch nicht wirklich gebraucht. Falls ihr euch dafür interessiert, schaut mal in die Dokumentation bei Microsoft: <a href=https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi target=_blank>https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi</a></p><h2 id=verknüpfte-instanzen>Verknüpfte Instanzen<a hidden class=anchor aria-hidden=true href=#verknüpfte-instanzen>#</a></h2><p>Was auch noch hilfreich sein kann: Verknüpfte Klassen - beziehungsweise eigentlich asoziierte Instanzen.
Zum Beispiel rufe ich mir erstmal alle physischen Netzwerkkarten an meinem Gerät ab:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Nur physische Netzwerkkarten abrufen:</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> Win32_NetworkAdapter -Filter <span style=color:#fc6a5d>&#34;PhysicalAdapter = 1&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Anschließend pipe ich mir das in <code>Get-CimAssociatedInstance</code> um alle damit zusammenhängenden Instanzen zu sehen:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> Win32_NetworkAdapter -Filter <span style=color:#fc6a5d>&#34;PhysicalAdapter = 1&#34;</span> | <span style=color:#d0a8ff>Get-CimAssociatedInstance</span>
</span></span></code></pre></td></tr></table></div></div><p>Anhand der Daten die jetzt ausgegeben werden, kann ich vielleicht ja schon sehen, dass hier etwas interessantes vorliegt. Ansonsten können wir uns diese Ausgabe auch noch an <code>Select-Object</code> pipen, um z.B. nur die Namen der Klassen zu sehen:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> Win32_NetworkAdapter -Filter <span style=color:#fc6a5d>&#34;PhysicalAdapter = 1&#34;</span> | <span style=color:#d0a8ff>Get-CimAssociatedInstance</span> | <span style=color:#d0a8ff>Select-Object</span> CimClass
</span></span></code></pre></td></tr></table></div></div><p>Oder um alle Eigenschaften zu sehen, die waren nämlich vorher nicht alle zu sehen:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> Win32_NetworkAdapter -Filter <span style=color:#fc6a5d>&#34;PhysicalAdapter = 1&#34;</span> | <span style=color:#d0a8ff>Get-CimAssociatedInstance</span> | <span style=color:#d0a8ff>Select-Object</span> *
</span></span></code></pre></td></tr></table></div></div><p>Wenn wir dadurch herausgefunden haben, dass uns eine bestimmte Klasse interessiert, dann können wir unseren ursprünglichen Abruf von <code>Get-CimAssociatedInstance</code> anpassen und nur noch diese eine Klasse dadurch abrufen:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> Win32_NetworkAdapter -Filter <span style=color:#fc6a5d>&#34;PhysicalAdapter = 1&#34;</span> | <span style=color:#d0a8ff>Get-CimAssociatedInstance</span> -ResultClassName Win32_NetworkAdapterConfiguration
</span></span></code></pre></td></tr></table></div></div><p>Dadurch konnte ich mir jetzt die Netzwerkkonfiguration für eine bestimmte Netzwerkkarte in meinem Computer anzeigen lassen.</p><h2 id=remote-wmi>Remote WMI<a hidden class=anchor aria-hidden=true href=#remote-wmi>#</a></h2><p>Am einfachsten geht Remote WMI, wenn unser aktuell angemeldeter User auch Admin-Rechte auf dem Remote System hat. Zum Beispiel:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> -ClassName Win32_Desktop -ComputerName CL5
</span></span></code></pre></td></tr></table></div></div><p>Alternativ können wir eine separate CimSession aufbauen und dabei dann andere Zugangsdaten angeben.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Credentials abfragen</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$Credential</span> = <span style=color:#d0a8ff>Get-Credential</span>
</span></span><span style=display:flex><span><span style=color:#6c7986># CIM Session aufbauen</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$CimSession</span> = <span style=color:#d0a8ff>New-CimSession</span> -ComputerName CL5 -Credential <span style=color:#41a1c0>$Credential</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># CIM/WMI Abfrage ausführen</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> -ClassName Win32_Desktop -CimSession <span style=color:#41a1c0>$CimSession</span> | <span style=color:#d0a8ff>Select-Object</span> Name,Wallpaper
</span></span></code></pre></td></tr></table></div></div><p>Wenn ihr mehrere WMI Aktionen gegen ein Remote System ausführen wollt, dann ist es übrigens effizienter, erstmal eine Session aufzubauen und dann die ganzen Befehle mit dem <code>-CimSession</code> Parameter auszuführen. Wenn bei <code>Get-CimInstance</code> der <code>-ComputerName</code> Parameter genutzt wird, dann wird nämlich jedes mal neu eine Verbindung aufgebaut, sich authentifiziert, der Befehl ausgeführt und am Ende die Verbindung beendet. Eine CimSession hingegen besteht weiter, bis sie aktiv beendet wird.</p><h3 id=wsman-und-dcom>WSMAN und DCOM<a hidden class=anchor aria-hidden=true href=#wsman-und-dcom>#</a></h3><p>WMI Remoting mit den CIM Befehlen verwendet im Hintergrund standardmäßig das WSMAN Protokoll. Falls Remote WMI bei euch noch nicht direkt funktioniert, dann könnt ihr es mit dem Cmdlet <code>Enable-PSRemoting</code> aktivieren. Die <a href=#deprecated-die-alten-wmi-cmdlets>älteren WMI-Cmdlets</a> verwenden übrigens DCOM statt WSMAN, was aber unter modernen Systemen im Standard von der Windows Firewall blockiert wird. Es wäre aber auch mit den CIM-Cmdlets möglich DCOM zu verwenden, falls es nötig ist. Die Details dazu findet ihr bei <a href="https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/07-working-with-wmi?view=powershell-7.4" target=_blank>Microsoft Learn</a>.</p><h3 id=mehrere-remote-systeme>Mehrere Remote Systeme<a hidden class=anchor aria-hidden=true href=#mehrere-remote-systeme>#</a></h3><p>Es ist auch möglich mit mehreren remote Systemen aufeinmal zu arbeiten. Dazu müsst ihr zunächst einmal mehrere CimSessions aufbauen, und sie dann an <code>Get-CimInstance</code> übergeben.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#41a1c0>$CimSession1</span> = <span style=color:#d0a8ff>New-CimSession</span> -ComputerName CL5 -Credential (<span style=color:#d0a8ff>Get-Credential</span>)
</span></span><span style=display:flex><span><span style=color:#41a1c0>$CimSession2</span> = <span style=color:#d0a8ff>New-CimSession</span> -ComputerName DC2 -Credential (<span style=color:#d0a8ff>Get-Credential</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> -ClassName Win32_Desktop -CimSession <span style=color:#41a1c0>$CimSession1</span>,<span style=color:#41a1c0>$CimSession2</span> | <span style=color:#d0a8ff>Select-Object</span> Name,Wallpaper
</span></span></code></pre></td></tr></table></div></div><h3 id=verbindung-trennen>Verbindung trennen<a hidden class=anchor aria-hidden=true href=#verbindung-trennen>#</a></h3><p>Wenn ihr eure Remotetätigkeiten abgeschlossen habt, dann solltet ihr auch die Verbindungen wieder trennen. Am einfachsten geht das per:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimSession</span> | <span style=color:#d0a8ff>Remove-CimSession</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=wmi-methoden-ausführen>WMI Methoden ausführen<a hidden class=anchor aria-hidden=true href=#wmi-methoden-ausführen>#</a></h2><p>Mit WMI können wir aber nicht nur Infos abrufen, sondern auch Methoden ausführen. Teilweise überschneiden die sich inhaltlich auch mit normalen PowerShell Cmdlets oder mit Methoden die per .NET verfügbar sind. Es kann aber auch sein, dass genau die Sache die ihr machen wollt, nur per WMI verfügbar ist.</p><p>Zum Beispiel rufe ich mir erstmal eine CIM Instanz ab, die sich auf einen bestimmten Drucker bezieht. Anschließend pipe ich die Instanz an <code>Invoke-CimMethod</code> um den Drucker als Standarddrucker zu definieren.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Standarddrucker per WMI setzen: Mit 2 Cmdlets</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> -ClassName Win32_Printer -Filter <span style=color:#fc6a5d>&#34;Name = &#39;Microsoft XPS Document Writer&#39;&#34;</span> | <span style=color:#d0a8ff>Invoke-CimMethod</span> -MethodName SetDefaultPrinter
</span></span></code></pre></td></tr></table></div></div><p>Ich musste jetzt hier zwei Cmdlets verwenden, weil <code>Invoke-CimMethod</code> nicht den <code>-Filter</code> Parameter unterstützt, der bei <code>Get-CimInstance</code> verfügbar ist. Ich <em>könnte</em> aber den <code>-Query</code> Parameter verwenden und einen WMI Query angeben, das hingegen wird von <code>Invoke-CimMethod</code> unterstützt.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Standarddrucker per WMI setzen: Nur 1 Cmdlet</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Invoke-CimMethod</span> -Query <span style=color:#fc6a5d>&#34;SELECT * FROM Win32_Printer WHERE Name = &#39;Microsoft XPS Document Writer&#39;&#34;</span> -MethodName SetDefaultPrinter
</span></span></code></pre></td></tr></table></div></div><p>Es muss aber auch nicht unbedingt eine bestimmte WMI Objektinstanz angesprochen werden. Einige Klassen unterstützen auch direkte Methodenaufrufe. Zum Beispiel:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Prozess starten per WMI</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Invoke-CimMethod</span> -ClassName Win32_Process -MethodName <span style=color:#fc6a5d>&#34;Create&#34;</span> -Arguments @{CommandLine = <span style=color:#fc6a5d>&#39;notepad.exe&#39;</span>}
</span></span></code></pre></td></tr></table></div></div><h3 id=wmi-remote-methodenaufrufe>WMI Remote Methodenaufrufe<a hidden class=anchor aria-hidden=true href=#wmi-remote-methodenaufrufe>#</a></h3><p>Grundsätzlich unterstützt <code>Invoke-CimMethod</code> auch das zuvor gezeigte Remoting. Also auch hier könnte wahlweise <code>-ComputerName</code> oder <code>-CimSession</code> verwendet werden.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Beispiel für einen remote WMI Methodenaufruf</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$MeineSession</span> = <span style=color:#d0a8ff>New-CimSession</span> -Credential (<span style=color:#d0a8ff>Get-Credential</span>) -ComputerName dc2
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Invoke-CimMethod</span> -ClassName Win32_Process -MethodName <span style=color:#fc6a5d>&#34;Create&#34;</span> -Arguments @{CommandLine = <span style=color:#fc6a5d>&#39;notepad.exe&#39;</span>} -CimSession <span style=color:#41a1c0>$MeineSession</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Wichtig</strong>: Wenn Prozesse remote gestartet werden, laufen die nicht sichtbar auf dem Desktop. Im Task Manager, oder zum Beispiel per <code>Get-Process</code> könnte man erkennen, dass die Prozesse laufen. Für das Beispiel <code>notepad.exe</code> ist das vielleicht nicht so sinnvoll, für andere Prozesse aber schon ✌️</p><h3 id=wmi-methoden-herausfinden>WMI Methoden herausfinden<a hidden class=anchor aria-hidden=true href=#wmi-methoden-herausfinden>#</a></h3><p>Wenn ihr schon eine WMI-Objektinstanz habt, dann könnt ihr direkt in der PowerShell schauen, welche Methoden zur Verfügung stehen:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Laufende notepad.exe Prozesse per WMI finden:</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$MeineCIMInstanz</span> = <span style=color:#d0a8ff>Get-CimInstance</span> Win32_Process -Filter <span style=color:#fc6a5d>&#34;Name = &#39;notepad.exe&#39;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Mit Get-Member können wir die leider NICHT sehen,</span>
</span></span><span style=display:flex><span><span style=color:#6c7986># da sie nicht als direkte Objektmethoden in PowerShell zur Verfügung stehen</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$MeineCIMInstanz</span> | <span style=color:#d0a8ff>Get-Member</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Stattdessen können wir auf die Eigenschaft CimClass.CimClassMehotds zugreifen</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$MeineCIMInstanz</span>.CimClass.CimClassMethods
</span></span></code></pre></td></tr></table></div></div><h2 id=wmi-objektinstanzen-löschen>WMI Objektinstanzen löschen<a hidden class=anchor aria-hidden=true href=#wmi-objektinstanzen-löschen>#</a></h2><p>Es gibt auch noch das Cmdlet <code>Remove-CimInstance</code> mit der WMI Objektinstanzen gelöscht werden <em>können</em>. Das ist in der Regel ein ⚠️ <strong>destruktiver Vorgang</strong> ⚠️, bei dem nicht einfach nur die Repräsentation des Objekts in der PowerShell entfernt wird, sondern das tatsächliche dahinterliegende Objekt wird zerstört. Also z.B. wenn ich die Objektinstanz eines laufenden Prozesses lösche, dann wird der Prozess beendet.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style=background-color:#353539><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Laufende notepad.exe Prozesse per WMI finden:</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> Win32_Process -Filter <span style=color:#fc6a5d>&#34;name = &#39;notepad.exe&#39;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Laufende notepad.exe Prozesse per WMI finden UND BEENDEN:</span>
</span></span><span style=display:flex;background-color:#353539><span><span style=color:#d0a8ff>Get-CimInstance</span> Win32_Process -Filter <span style=color:#fc6a5d>&#34;name = &#39;notepad.exe&#39;&#34;</span> | <span style=color:#d0a8ff>Remove-CimInstance</span>
</span></span></code></pre></td></tr></table></div></div><p>Was genau passiert, kommt natürlich auf die konkrete Klasse an. Aber am besten verwendet ihr das <code>Remove-CimInstance</code> Cmdlet mit äußerster Vorsicht.</p><h2 id=wmi-klassen-eigenschaften-und-methoden-herausfinden>WMI Klassen, Eigenschaften und Methoden herausfinden<a hidden class=anchor aria-hidden=true href=#wmi-klassen-eigenschaften-und-methoden-herausfinden>#</a></h2><p>Um alle WMI Klassen aufzulisten, die es am System gibt, könnt ihr das Cmdlet <code>Get-CimClass</code> verwenden. Je nach System sind das auch unterschiedlich viele, aber auf einem modernen Windows 11 System locker über 2000. Und die ein oder andere Hard- oder Software bringt noch eigene Klassen mit.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Klassen auflisten</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Klassen zählen</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span> | <span style=color:#d0a8ff>Measure-Object</span>
</span></span></code></pre></td></tr></table></div></div><p>Zu den Namen der Klassen:</p><ul><li>Fängt mit <code>__</code> an: Systemklasse</li><li>Fängt mit <code>MSFT</code> an: Systemklasse</li><li>Fängt mit <code>CIM</code> an: Basis CIM Klasse (meist gibt es eine bessere <code>Win32</code> Klasse als Alternative)</li><li>⭐ Fängt mit <code>Win32</code> an: Erweiterte WMI Klasse (basiert auf CIM Standard-Klassen)</li><li>Fängt mit <code>Win32_Perf</code> an: Performance Counter Klasse</li><li>Fängt mit <code>Win32_PnPDevice</code> an: Plug and Play Device Klasse</li><li>⭐ Fängt komplett anders an: Könnte auch interessant sein</li></ul><p>Siehe dazu auch: <a href=https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-classes target=_blank>https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-classes</a></p><p>Es gibt teilweise <code>CIM</code> und <code>Win32</code> Klassen die sich inhaltlich überschneiden. In der Regel ist die <code>Win32</code> Klasse dann mächtiger. Zum Beispiel hat die Klasse <code>Win32_Process</code> bei mir 45 Properties und 7 Methoden, im Gegensatz zur <code>CIM_Process</code> Klasse, die nur 18 Properties und gar keine Methoden hat.</p><p>Die Methoden und Eigenschaften einer Klasse sind in den Eigenschaften <code>CimClassMethods</code> und <code>CimClassProperties</code> aufgeführt.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Eigenschaften und Methoden der CIM_Process Klasse zählen:</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span> -ClassName Cim_Process | <span style=color:#d0a8ff>Select-Object</span> -ExpandProperty CimClassProperties | <span style=color:#d0a8ff>Measure-Object</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span> -ClassName Cim_Process | <span style=color:#d0a8ff>Select-Object</span> -ExpandProperty CimClassMethods | <span style=color:#d0a8ff>Measure-Object</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Eigenschaften und Methoden der Win32_Process Klasse zählen:</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span> -ClassName Win32_Process | <span style=color:#d0a8ff>Select-Object</span> -ExpandProperty CimClassProperties | <span style=color:#d0a8ff>Measure-Object</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span> -ClassName Win32_Process | <span style=color:#d0a8ff>Select-Object</span> -ExpandProperty CimClassMethods | <span style=color:#d0a8ff>Measure-Object</span>
</span></span></code></pre></td></tr></table></div></div><p>Ich bevorzuge es aber, mir die Infos in der offiziellen Dokumentation anzuschauen. Wenn ich einfach nach <code>Win32_Process</code> in einer Suchmaschine suche, dann lande ich schnell bei der <a href=https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process target=_blank>richtigen Dokumentation</a>. Vorteil ist: Dort gibt es in der Regel auch Beschreibungen und Beispiele für die Eigenschaften und Methoden.</p><h3 id=wmi-namespaces>WMI Namespaces<a hidden class=anchor aria-hidden=true href=#wmi-namespaces>#</a></h3><p>Wie euch vielleicht bei der Rückgabe von <code>Get-CimClass</code> aufgefallen ist: Über der Liste der Ergebnisse steht noch: &ldquo;NameSpace: ROOT/cimv2&rdquo;.</p><p>Die Klassen sind in sogenannten Namespaces einsortiert - so ähnlich wie Ordner im Dateisystem. Zusätzliche Hard- oder Softwares bringen teilweise eigene Namespaces mit, in denen dann zusätzliche WMI Klassen drin sind. <code>root/cimv2</code> ist einfach der Standard Namespace von Windows. Und wenn wir <code>Get-CimClass</code> ohne weitere Parameter aufrufen, dann werden uns nur die Klassen in diesem Standard Namespace aufgelistet. Es gibt aber noch mehr Namespaces.
Die Definition der Namespaces kann ich über die System Klasse <code>__Namespace</code> abrufen, muss aber auch mit angeben, dass ich diese Definition im Namespace <code>root</code> ansehen möchte (ohne <code>cimv2</code>, das ist nämlich schon ein Unter-Namespace von <code>root</code>):</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#d0a8ff>Get-CimInstance</span> __NAMESPACE -Namespace root
</span></span></code></pre></td></tr></table></div></div><p>Auf einem Domänencontroller habe ich auch schon andere Namespaces als auf einem Windows 11 Client. Zum Beispiel gibt es auf meinem DC den Namespace <code>MicrosoftActiveDirectory</code>.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Infos zur Klasse MicrosoftActiveDirectory im Namespace root abrufen:</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span> -Namespace root/MicrosoftActiveDirectory
</span></span></code></pre></td></tr></table></div></div><p>Tatsächlich können Namespaces auch noch weitere Namespaces enthalten. Zum Beispiel sind im Standard Namespace <code>root/cimv2</code> auch noch weitere Unter-Namespaces vorhanden.
Mit einer kleinen selbstgeschriebenen Funktion können wir uns alle Namespaces auflisten.</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#fc5fa3>function</span> <span style=color:#d0a8ff>Get-CimNamespace</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7986># Funktion um CIM Namespaces rekursiv abzurufen</span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>param</span>(<span style=color:#41a1c0>$NameSpace</span> = <span style=color:#fc6a5d>&#34;root&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fc5fa3>foreach</span>(<span style=color:#41a1c0>$thisNamespace</span> <span style=color:#fc5fa3>in</span> (<span style=color:#d0a8ff>Get-CimInstance</span> __NAMESPACE -Namespace <span style=color:#41a1c0>$NameSpace</span>)) {
</span></span><span style=display:flex><span>        (<span style=color:#41a1c0>$SubNameSpace</span> = <span style=color:#fc6a5d>&#34;{0}\{1}&#34;</span> -f <span style=color:#41a1c0>$NameSpace</span>,<span style=color:#41a1c0>$thisNamespace</span>.Name) <span style=color:#6c7986># this line sets the var and also outputs it ;)</span>
</span></span><span style=display:flex><span>        <span style=color:#d0a8ff>Get-CimNamespace</span> -NameSpace <span style=color:#41a1c0>$SubNameSpace</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6c7986># Alle Namespaces in eine Variable laden</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$AllCimNameSpaces</span> = <span style=color:#d0a8ff>Get-CimNamespace</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fc6a5d>&#34;Found </span>$(<span style=color:#41a1c0>$AllCimNameSpaces</span>.Count)<span style=color:#fc6a5d> NameSpaces.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$AllCimNameSpaces</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Alle Klassen aus allen Namespaces abrufen:</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$AllCimClasses</span> = <span style=color:#41a1c0>$AllCimNameSpaces</span> | <span style=color:#d0a8ff>ForEach-Object</span> { <span style=color:#d0a8ff>Get-CimClass</span> -Namespace <span style=color:#41a1c0>$_</span> }
</span></span><span style=display:flex><span><span style=color:#fc6a5d>&#34;Found </span>$(<span style=color:#41a1c0>$AllCimClasses</span>.Count)<span style=color:#fc6a5d> Classes:&#34;</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$AllCimClasses</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Doppelte Klassen herausfiltern und das Ergebnis zählen:</span>
</span></span><span style=display:flex><span><span style=color:#41a1c0>$AllCimClasses</span> | <span style=color:#d0a8ff>Sort-Object</span> -Property CimClassName -Unique | <span style=color:#d0a8ff>Measure-Object</span>
</span></span></code></pre></td></tr></table></div></div><p>Generell spielt sich - meiner Meinung nach - aber auch viel wichtiges in dem Standard Namespace <code>root/cimv2</code> ab. Aber das kommt natürlich darauf an, was ihr mit WMI gerade machen wollt.</p><h3 id=wmi-klassen-finden>WMI Klassen finden<a hidden class=anchor aria-hidden=true href=#wmi-klassen-finden>#</a></h3><p>Falls ihr noch nicht wisst, welche Klasse ihr braucht, könnt ihr mit <code>Get-CimClass</code> auch suchen. Wenn ihr vermutet, dass der Name der Klasse ein bestimmtes Wort enthält, könnt ihr Wildcards verwenden und suchen:</p><div class=highlight><div style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#6c7986># Suche nach WMI/CIM Klassen die &#34;process&#34; im Namen haben</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span> -ClassName *<span style=color:#fc5fa3>process</span>*
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Suche nach WMI/CIM Klassen, bei denen es eine Methode gibt,</span>
</span></span><span style=display:flex><span><span style=color:#6c7986># die &#34;reboot&#34; im Namen hat</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span> -MethodName *reboot*
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7986># Suche nach WMI/CIM Klassen, bei denen es eine Property gibt,</span>
</span></span><span style=display:flex><span><span style=color:#6c7986># die &#34;wallpaper&#34; im Namen hat</span>
</span></span><span style=display:flex><span><span style=color:#d0a8ff>Get-CimClass</span> -PropertyName *wallpaper*
</span></span></code></pre></td></tr></table></div></div><p>Ansonsten gibt es auch noch grafische Tools die dabei helfen können, wie z.B. den <a href=https://github.com/vinaypamnani/wmie2 target=_blank>WMI Explorer von Vinay Pamnani</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://diecknet.de/de/tags/powershell/>Powershell</a></li></ul><div class=share-buttons></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://diecknet.de/de/>diecknet</a></span>
&nbsp;|&nbsp;
<span><a href=https://diecknet.de/de/legal/>Impressum</a>
</span>&nbsp;|&nbsp;<span>
<a href=https://diecknet.de/de/privacy/>Datenschutz</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Kopieren";function s(){t.innerHTML="Kopiert!",setTimeout(()=>{t.innerHTML="Kopieren"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script type=text/javascript>var _paq=window._paq||[];_paq.push(["disableCookies"]),_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){t="//nc.diecknet.de/mt/",_paq.push(["setTrackerUrl",t+"mdata"]),_paq.push(["setSiteId","1"]);var t,n=document,e=n.createElement("script"),s=n.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.defer=!0,e.src=t+"m.js",s.parentNode.insertBefore(e,s)}()</script><noscript><p><img src="https://nc.diecknet.de/mt/mdata?idsite=1&amp;rec=1" style=border:0 alt></p></noscript></body></html>